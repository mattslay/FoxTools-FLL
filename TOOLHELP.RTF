{\rtf1\ansi\deff11
{\fonttbl{\f0\fnil Times New Roman;}{\f1\fnil Arial;}{\f2\fmodern Courier New;}{\f3\fnil Symbol;}{\f4\fnil Times;}{\f5\fnil Helvetica;}{\f6\fnil Courier;}{\f7\fnil Geneva;}{\f8\fnil Tms Rmn;}{\f9\fnil Helv;}{\f10\fnil MS Serif;}{\f11\fswiss MS Sans Serif;}{\f12\fnil New York;}{\f13\fnil System;}{\f14\fnil Wingdings;}{\f15\fnil Mincho;}{\f16\fnil Batang;}{\f17\fnil SimSun;}{\f18\fnil PMingLiU;}{\f19\fnil Gothic;}{\f20\fnil Dotum;}{\f21\fnil SimHei;}{\f22\fnil MingLiU;}{\f23\fnil MS Mincho;}{\f24\fnil Gulim;}{\f25\fnil MS Gothic;}{\f26\fnil Century;}{\f27\fnil Tahoma;}{\f28\fnil Marlett;}{\f29\fnil Humnst777 BT;}{\f30\fnil Humnst777 Cn BT;}{\f31\fnil Arial Black;}{\f32\fnil Comic Sans MS;}{\f33\fnil Impact;}{\f34\fnil Verdana;}{\f35\fnil Mistral;}{\f36\fnil Arial Narrow;}{\f37\fnil Wingdings 2;}{\f38\fnil MT Extra;}{\f39\fnil MS Reference 1;}{\f40\fnil MS Reference 2;}{\f41\fnil Times New Roman Special G1;}{\f42\fnil Times New Roman Special G2;}{\f43\fnil Arial Rounded MT Bold;}{\f44\fnil Bookman Old Style;}{\f45\fnil Century Gothic;}{\f46\fnil Haettenschweiler;}{\f47\fnil Algerian;}{\f48\fnil Braggadocio;}{\f49\fnil Britannic Bold;}{\f50\fnil Brush Script MT;}{\f51\fnil Colonna MT;}{\f52\fnil Desdemona;}{\f53\fnil Footlight MT Light;}{\f54\fnil Garamond;}{\f55\fnil Kino MT;}{\f56\fnil Wide Latin;}{\f57\fnil Matura MT Script Capitals;}{\f58\fnil Playbill;}{\f59\fnil MS LineDraw;}{\f60\fnil CRL_1;}{\f61\fnil Billboard;}{\f62\fnil Excalibur Logotype;}{\f63\fnil Excalibur Monospace;}{\f64\fnil Excalibur Script;}{\f65\fnil Kool;}{\f66\fnil Olde English;}{\f67\fnil Tapestry;}{\f68\fnil Radius;}{\f69\fnil OCR-A;}{\f70\fnil QuickType Mono;}{\f71\fnil QuickType;}{\f72\fnil QuickType Condensed;}{\f73\fnil QuickType Pi;}{\f74\fnil Mini Pics Art Jam;}{\f75\fnil Mini Pics Classic;}{\f76\fnil Mini Pics Lil Critters;}{\f77\fnil Mini Pics Lil Edibles;}{\f78\fnil Mini Pics Lil Events;}{\f79\fnil Mini Pics Lil Stuff;}{\f80\fnil Mini Pics Lil Vehicles;}{\f81\fnil Mini Pics Red Rock;}{\f82\fnil Modern;}{\f83\fnil MS Dialog;}{\f84\fnil FoxPrint;}{\f85\fnil LinePrinter;}{\f86\fnil CG Times;}{\f87\fnil Univers;}{\f88\fnil Univers Condensed;}{\f89\fnil Antique Olive;}{\f90\fnil CG Omega;}{\f91\fnil Albertus Medium;}{\f92\fnil Albertus Extra Bold;}{\f93\fnil Clarendon Condensed;}{\f94\fnil Coronet;}{\f95\fnil Letter Gothic;}{\f96\fnil Marigold;}{\f97\fnil LotusWP Int A;}{\f98\fnil LotusWP Int B;}{\f99\fnil LotusWP Box;}{\f100\fnil LotusWP Type;}{\f101\fnil LotusWP Icon;}{\f102\fnil Math A;}{\f103\fnil Math B;}{\f104\fnil Math C;}{\f105\fnil Lotus Postal Barcode;}{\f106\fnil Baskerville;}{\f107\fnil Binner Gothic;}{\f108\fnil Centaur;}{\f109\fnil Gill Sans;}{\f110\fnil Gill Sans Condensed;}{\f111\fnil Gill Sans Ultra Bold;}{\f112\fnil Monotype Sorts;}{\f113\fnil News Gothic;}{\f114\fnil Nimrod;}{\f115\fnil Onyx;}{\f116\fnil Botanical;}{\f117\fnil Rockwell;}{\f118\fnil Rockwell Condensed;}{\f119\fnil Rockwell Light;}{\f120\fnil Abadi MT Condensed;}{\f121\fnil Wingdings 3;}{\f122\fnil LotusWPSet;}{\f123\fnil LotusLineDraw;}{\f124\fnil Arial Condensed Bold;}{\f125\fnil Bodoni Black;}{\f126\fnil Bodoni Book;}{\f127\fnil New Berolina;}{\f128\fnil Old Style Bold Outline;}{\f129\fnil Palace Script;}{\f130\fnil Photina;}{\f131\fnil MS Sans Ser;}{\f132\fnil MS Sans Serif`;}{\f133\fnil Lucida Console;}{\f134\fnil Book Antiqua;}{\f135\fnil Monotype Corsiva;}{\f136\fnil MS Outlook;}{\f137\fnil Trebuchet MS;}{\f138\fnil Webdings;}{\f139\fnil Map Symbols;}{\f140\fnil News Gothic MT;}{\f141\fnil Lucida Handwriting;}{\f142\fnil Lucida Sans;}{\f143\fnil Lucida Sans Unicode;}{\f144\fnil OCR A Extended;}{\f145\fnil Calisto MT;}{\f146\fnil Abadi MT Condensed Light;}{\f147\fnil Copperplate Gothic Bold;}{\f148\fnil Copperplate Gothic Light;}{\f149\fnil Matisse ITC;}{\f150\fnil Tempus Sans ITC;}{\f151\fnil Westminster;}{\f152\fnil Tahoma (Hebrew);}{\f153\fnil Tahoma (Arabic);}{\f154\fnil Lucida Sans Unicode (Hebrew);}{\f155\fnil ms san serif;}{\f156\fnil MS Sans Seriif;}{\f157\fnil Chessmaster 5500;}{\f158\fnil Times New Roman (Hebrew);}{\f159\fnil Times New Roman (Arabic);}{\f160\fnil Arial (Hebrew);}{\f161\fnil Arial (Arabic);}{\f162\fnil Courier New (Hebrew);}{\f163\fnil Courier New (Arabic);}{\f164\fnil Vixar ASCI;}{\f165\fnil Tempo Grunge;}{\f166\fnil Almanac MT;}{\f167\fnil Baskerville Old Face;}{\f168\fnil Bauhaus 93;}{\f169\fnil Beesknees ITC;}{\f170\fnil Bell MT;}{\f171\fnil Bernard MT Condensed;}{\f172\fnil Blackadder ITC;}{\f173\fnil Bradley Hand ITC;}{\f174\fnil Broadway;}{\f175\fnil Castellar;}{\f176\fnil Century Schoolbook;}{\f177\fnil Chiller;}{\f178\fnil Cooper Black;}{\f179\fnil Curlz MT;}{\f180\fnil Edwardian Script ITC;}{\f181\fnil Engravers MT;}{\f182\fnil Eras Bold ITC;}{\f183\fnil Eras Demi ITC;}{\f184\fnil Eras Medium ITC;}{\f185\fnil Felix Titling;}{\f186\fnil Forte;}{\f187\fnil Franklin Gothic Heavy;}{\f188\fnil Franklin Gothic Medium;}{\f189\fnil Franklin Gothic Medium Cond;}{\f190\fnil French Script MT;}{\f191\fnil Georgia;}{\f192\fnil Gigi;}{\f193\fnil Gill Sans MT;}{\f194\fnil Gill Sans MT Condensed;}{\f195\fnil Gill Sans MT Ext Condensed Bold;}{\f196\fnil Gill Sans Ultra Bold Condensed;}{\f197\fnil Gloucester MT Extra Condensed;}{\f198\fnil Goudy Old Style;}{\f199\fnil Goudy Stout;}{\f200\fnil Harlow Solid Italic;}{\f201\fnil Harrington;}{\f202\fnil Holidays MT;}{\f203\fnil Imprint MT Shadow;}{\f204\fnil Informal Roman;}{\f205\fnil Jokerman;}{\f206\fnil Juice ITC;}{\f207\fnil Kristen ITC;}{\f208\fnil Kunstler Script;}{\f209\fnil Lucida Calligraphy;}{\f210\fnil Lucida Sans Typewriter;}{\f211\fnil Maiandra GD;}{\f212\fnil Modern No. 20;}{\f213\fnil Monotype Sorts 2;}{\f214\fnil Palace Script MT;}{\f215\fnil Papyrus;}{\f216\fnil Pepita MT;}{\f217\fnil Perpetua;}{\f218\fnil Perpetua Titling MT;}{\f219\fnil Pristina;}{\f220\fnil Rage Italic;}{\f221\fnil Rockwell Extra Bold;}{\f222\fnil Script MT Bold;}{\f223\fnil Snap ITC;}{\f224\fnil Stencil;}{\f225\fnil Tw Cen MT;}{\f226\fnil Tw Cen MT Condensed;}{\f227\fnil Tw Cen MT Condensed Extra Bold;}{\f228\fnil Vacation MT;}{\f229\fnil Viner Hand ITC;}{\f230\fnil Vivaldi;}{\f231\fnil Vladimir Script;}{\f232\fnil Franklin Gothic Demi;}{\f233\fnil Franklin Gothic Demi Cond;}{\f234\fnil Verdana Ref;}{\f235\fnil Georgia Ref;}{\f236\fnil RefSpecialty;}{\f237\fnil MS Reference Sans Serif;}{\f238\fnil MS Reference Serif;}{\f239\fnil MS Reference Specialty;}{\f240\fnil Arial Special G1;}{\f241\fnil Arial Special G2;}{\f242\fnil Arial Narrow Special G1;}{\f243\fnil Arial Narrow Special G2;}{\f244\fnil Franklin Gothic Medium Cond Gre;}{\f245\fnil Franklin Gothic Medium Cond Bal;}{\f246\fnil Franklin Gothic Demi Cond Balti;}{\f247\fnil Times New Roman CE;}{\f248\fnil Times New Roman Cyr;}{\f249\fnil Times New Roman Greek;}{\f250\fnil Times New Roman Tur;}{\f251\froman Times New Roman Baltic;}}
{\colortbl;\red0\green0\blue255;}
{\stylesheet{\fs20 \snext0 Normal;}
}\pard\plain
\pard\keepn\sb235\sa55 \b\fs20 Extended Foxtools Help
\par \pard \plain\uldb\fs20 
\par About Extended Foxtools Help\plain\fs20 {\v B.03XH}
\par \uldb Acknowledgements\plain\fs20 {\v 1.U11UJ}\uldb 
\par Alphabetical Function List\plain\fs20 {\v B.D4K5}\uldb 
\par Clipboard Functions\plain\fs20 {\v 2P4NVVT}\uldb 
\par Exposed FoxPro Editor API Functions\plain\fs20 {\v FTAPI}
\par \uldb Exposed FoxPro Window API Functions\plain\fs20 {\v FTWAPI}\uldb 
\par File & Drive Functions\plain\fs20 {\v 9P9SDS}\uldb 
\par String Functions\plain\fs20 {\v UURZGK}\uldb 
\par Miscellaneous Functions\plain\fs20 {\v FTMISC}
\par \uldb Functions Added To The Languge In Version 6.0\plain\fs20 {\v BG5ZD.}
\par \uldb New Functions in Foxtools 6.0\plain\fs20 {\v .EN3EU}\uldb 
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0001}
{\up $}{\footnote\pard\plain{\up $} About Extended Help}
{\up #}{\footnote\pard\plain{\up #} B.03XH}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} About}
\plain\b\fs20 About Extended Foxtools Help
\par \pard \plain\fs20 
\par Information contained in this help file has been obtained from a number of sources. These include the FOXTOOLS.WRI file included in FoxPro for Windows 2.x, the Microsoft Knowledge Base, the Library Construction Kit, and the Visual FoxPro 5.0 Help File.
\par 
\par Additional information, especially that connected with the FoxPro API functions exposed by FOXTOOLS, has been obtained mostly been through trial and error by the author. Naturally, no warranty is either intended or implied by the publication of this document. Indeed, since the library was first released, Microsoft\f251 \'92\f11 s stated position has been and is one of no guarantee of current or future support. However, through five versions, no functions have been removed except those incorporated into the language proper, but some have been added. This help file is complete through version 6.0.
\par \pard 
\par I would appreciate any feedback regarding this work. This includes correction of any errors found, or suggestions as to providing additional examples. Feel free to email me at : gtasker@compuserve.com
\par 
\par George Tasker
\par February 21, 1998
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0002}
{\up $}{\footnote\pard\plain{\up $} Acknowledgements}
{\up #}{\footnote\pard\plain{\up #} 1.U11UJ}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} Acknowledgements}
\b Acknowledgements
\par \pard \plain\fs20 
\par I would like to acknowledge the following people:
\par 
\par Rick Strahl of West Wind Technologies, for sparking my interest in the API functions.
\par 
\par Steve Despres and Roxanne Seibert for their words of encouragement.
\par 
\par David Frankenbach for pointing out the FoxTouch() function and a source of information about it.
\par 
\par Robert Green of Microsoft, for encouraging me to expand this project
\par 
\par Michel Fournier of Fournier Transformation, Inc., for providing the Universal Thread as a means of distribution.
\par \pard 
\par Joshua D. Weiss of Boston Microcomputer Consulting, for providing the information regarding the functions from the library added to the language in version 6.0.
\par 
\par Christof Lange, The Foxpert!, for information on a documentation source for the functions _WsockStartUp(), _WSockGetHostByAddr(), and _WSockCleanUp(). Christof also provided additional information for the last element of the array populated by _EdGetEnv(). Further, Christof\f251 \'92\f11 s feedback on one of his projects led directly to the section entitled, \'93Invalid whandles\'94 and additional information on _EdGetLNum() and _EdGetLPos(). My thanks to him for his continuing feedback and support of this project. Most recently he has provided information regarding problems with _EGetEnv(). His continued support of this project is greatly appreciated.
\par \pard 
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0003}
{\up $}{\footnote\pard\plain{\up $} Alphabetical Functions}
{\up #}{\footnote\pard\plain{\up #} B.D4K5}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} Alphabetical Function List}
\b Alphabetical Function List
\par \pard \uldb \plain\uldb\fs20 AddBS\plain\fs20 {\v 14EGS1W}
\par \uldb CallFN\plain\fs20 {\v 211_Z8Q}
\par \uldb CleanPath\plain\fs20 {\v C1HUI2}
\par \uldb CloseClip\plain\fs20 {\v LI4.7L}
\par \uldb CountClipF\plain\fs20 {\v 54EH_S9}
\par \uldb DefaultExt\plain\fs20 {\v JCX88A}
\par \uldb DriveType\plain\fs20 {\v 074B7F}
\par \uldb EmptyClip\plain\fs20 {\v 11NJOWG}
\par \uldb EnumClipFm\plain\fs20 {\v 12SSV0G}
\par \uldb ForceExt\plain\fs20 {\v 36PZ07N}
\par \uldb ForcePath\plain\fs20 {\v H1ZPGF}
\par \uldb FoxToolVer\plain\fs20 {\v 31VC9DH}
\par \uldb FoxTouch\plain\fs20 {\v I_4KEX}\uldb 
\par GetClipDat\plain\fs20 {\v _708YP}
\par \uldb GetClipFmt\plain\fs20 {\v 3N0K8YJ}
\par \uldb GetFileVersion\plain\fs20 {\v IP6OP8}
\par \uldb GetProStrg\plain\fs20 {\v 19B.QHP}
\par \uldb IsClipFmt\plain\fs20 {\v 1HSGYXC}
\par \uldb JustDrive\plain\fs20 {\v OPGGH3}
\par \uldb JustExt\plain\fs20 {\v 2EALD5}
\par \uldb JustFName\plain\fs20 {\v 2QC._Z8}
\par \uldb JustPath\plain\fs20 {\v CQ2YEC}
\par \uldb JustStem\plain\fs20 {\v CQ6A6H}
\par \uldb MainHwnd\plain\fs20 {\v 18_H6X8}
\par \uldb MkDir\plain\fs20 {\v BHBSLF}
\par \pard \uldb MsgBox\plain\fs20 {\v 1I9WPUK}
\par \uldb NextWord\plain\fs20 {\v _64OBQ}
\par \uldb OpenClip\plain\fs20 {\v 7XJE.L}
\par \uldb PutProStrg\plain\fs20 {\v XDITBE}
\par \uldb Reduce\plain\fs20 {\v 1MVU8I8}
\par \uldb RegClipFmt\plain\fs20 {\v 1GPWPV0}
\par \uldb RegFN\plain\fs20 {\v BM.VIB}
\par \uldb RegFN32\plain\fs20 {\v BM.VIB}
\par \uldb RGBComp\plain\fs20 {\v WX9ZQ_}
\par \uldb RmDir\plain\fs20 {\v BMDSLF}
\par \uldb SetClipDat\plain\fs20 {\v LSILHM}
\par \uldb StrFilter\plain\fs20 {\v 1E2V3OK}
\par \uldb ValidPath\plain\fs20 {\v 36PDQE}
\par \uldb WordNum\plain\fs20 {\v 4PUMZUE}
\par \uldb Words\plain\fs20 {\v BRG6GG}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0004}
{\up $}{\footnote\pard\plain{\up $} Clipboard Functions}
{\up #}{\footnote\pard\plain{\up #} 2P4NVVT}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} Clipboard Functions}
\b Clipboard Functions
\par \pard \uldb \plain\uldb\fs20 CloseClip\plain\fs20 {\v LI4.7L}
\par \uldb CountClipF\plain\fs20 {\v 54EH_S9}
\par \uldb EmptyClip\plain\fs20 {\v 11NJOWG}
\par \uldb EnumClipFm\plain\fs20 {\v 12SSV0G}
\par \uldb GetClipDat\plain\fs20 {\v _708YP}
\par \uldb GetClipFmt\plain\fs20 {\v 3N0K8YJ}
\par \uldb IsClipFmt\plain\fs20 {\v 1HSGYXC}
\par \uldb OpenClip\plain\fs20 {\v 7XJE.L}
\par \uldb RegClipFmt\plain\fs20 {\v 1GPWPV0}
\par \uldb SetClipDat\plain\fs20 {\v LSILHM}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0005}
{\up $}{\footnote\pard\plain{\up $} File and Drive Functions}
{\up #}{\footnote\pard\plain{\up #} 9P9SDS}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} Drives;File and Drive Functions;Files}
\b File and Drive Functions
\par \pard \uldb \plain\uldb\fs20 AddBS\plain\fs20 {\v 14EGS1W}
\par \uldb CleanPath\plain\fs20 {\v C1HUI2}
\par \uldb DefaultExt\plain\fs20 {\v JCX88A}
\par \uldb DriveType\plain\fs20 {\v 074B7F}
\par \uldb ForceExt\plain\fs20 {\v 36PZ07N}
\par \uldb ForcePath\plain\fs20 {\v H1ZPGF}
\par \uldb FoxTouch\plain\fs20 {\v I_4KEX}\uldb 
\par JustDrive\plain\fs20 {\v OPGGH3}
\par \uldb JustExt\plain\fs20 {\v 2EALD5}
\par \uldb JustFName\plain\fs20 {\v 2QC._Z8}
\par \uldb JustPath\plain\fs20 {\v CQ2YEC}
\par \uldb JustStem\plain\fs20 {\v CQ6A6H}
\par \uldb MkDir\plain\fs20 {\v BHBSLF}
\par \uldb RmDir\plain\fs20 {\v BMDSLF}
\par \uldb ValidPath\plain\fs20 {\v 36PDQE}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0006}
{\up $}{\footnote\pard\plain{\up $} String Functions}
{\up #}{\footnote\pard\plain{\up #} UURZGK}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} Strings}
\b String Functions
\par \pard \uldb \plain\uldb\fs20 NextWord\plain\fs20 {\v _64OBQ}
\par \uldb Reduce\plain\fs20 {\v 1MVU8I8}
\par \uldb StrFilter\plain\fs20 {\v 1E2V3OK}
\par \uldb WordNum\plain\fs20 {\v 4PUMZUE}
\par \uldb Words\plain\fs20 {\v BRG6GG}
\par 
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0007}
{\up $}{\footnote\pard\plain{\up $} Editor API Functions}
{\up #}{\footnote\pard\plain{\up #} FTAPI}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} Editor;VFP API}
\b Exposed FoxPro Editor API Functions
\par \pard\tx355 \uldb \plain\uldb\fs20 _EdActive\plain\fs20 {\v A7FFBK}\tab \tab \tab \uldb _EdPaste\plain\fs20 {\v 468VNP}
\par \uldb _EdCloseFi\plain\fs20 {\v 11I9_ZG}\tab \tab \tab \uldb _EdPosInvi\plain\fs20 {\v 18HMP1D}
\par \uldb _EdComment\plain\fs20 {\v 367W.RW}\tab \tab \tab \uldb _EdProcList\plain\fs20 {\v RELHQC}
\par \uldb _EdCopy\plain\fs20 {\v 1C.3RW}\tab \tab \tab \uldb _EdProperties\plain\fs20 {\v 12T4H7T}
\par \uldb _EdCut\plain\fs20 {\v 14IGRDX}\tab \tab \tab \tab \uldb _EdRedo\plain\fs20 {\v 1CJTFM}
\par \uldb _EdDelete\plain\fs20 {\v 8JRM.W4}\tab \tab \tab \uldb _EdRevert\plain\fs20 {\v 26L5ABO}
\par \uldb _EdGetChar\plain\fs20 {\v 57VD36}\tab \tab \tab \uldb _EdSelect\plain\fs20 {\v 27KVA3O}
\par \uldb _EdGetEnv\plain\fs20 {\v 19BRARA}\tab \tab \tab \uldb _EdSendKey\plain\fs20 {\v 3.0.M4D}
\par \uldb _EdGetLNum\plain\fs20 {\v 584JG1}\tab \tab \tab \uldb _EdSetEnv\plain\fs20 {\v 1EBRARA}
\par \uldb _EdGetLPos\plain\fs20 {\v 584LA7}\tab \tab \tab \uldb _EdSetPos\plain\fs20 {\v 3G3KKCC}
\par \uldb _EdGetPos\plain\fs20 {\v 3X.WJZS}\tab \tab \tab \uldb _EdSkipLin\plain\fs20 {\v 2OW.NKT}
\par \uldb _EdGetStr\plain\fs20 {\v 19BROX_}\tab \tab \tab \uldb _EdStoPos\plain\fs20 {\v 2U90KW3}
\par \pard\tx355 \uldb _EdIndent\plain\fs20 {\v IB6B0Z}\tab \tab \tab \uldb _EdStoSel\plain\fs20 {\v SHAP1R}
\par \uldb _EdInsert\plain\fs20 {\v 1XU2ABO}\tab \tab \tab \uldb _EdUndo\plain\fs20 {\v 1CN2FM}
\par \uldb _EdLastErr\plain\fs20 {\v XUJD8W}\tab \tab \tab \uldb _EdUndoOn\plain\fs20 {\v 88ULOD}
\par \uldb _EdOpenFil\plain\fs20 {\v 90RGOG}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0008}
{\up $}{\footnote\pard\plain{\up $} Window API Functions}
{\up #}{\footnote\pard\plain{\up #} FTWAPI}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} VFP API;Windows}
\b Exposed FoxPro Window API Functions
\par \pard\tx355 \uldb \plain\uldb\fs20 _FindWindo\plain\fs20 {\v 7G7YBX}\tab \tab \tab \uldb _WOpen\plain\fs20 {\v BRG4HB}
\par \uldb _FindWindp\plain\fs20 {\v 7G7YBY}\tab \tab \tab \uldb _WOpenP\plain\fs20 {\v CNHTPN}\uldb 
\par _GetWRect\plain\fs20 {\v 8REQUZ}\tab \tab \tab \uldb _WPutChr\plain\fs20 {\v 233XQA5}
\par \uldb _WAttr\plain\fs20 {\v BR98WF}\tab \tab \tab \tab \uldb _WPutStr\plain\fs20 {\v 233Y6M5}
\par \uldb _WBottom\plain\fs20 {\v 3QIR685}\tab \tab \tab \uldb _WPosCurso\plain\fs20 {\v 33Z_TBN}
\par \uldb _WBottomP\plain\fs20 {\v 99EO9S}\tab \tab \tab \uldb _WPosCurP\plain\fs20 {\v 1Z_42H5}
\par \uldb _WClear\plain\fs20 {\v CBDTCP}\tab \tab \tab \uldb _WRight\plain\fs20 {\v CQAVJR}
\par \uldb _WClearRec\plain\fs20 {\v 1.Y.3FA}\tab \tab \tab \uldb _WRightP\plain\fs20 {\v 36RX1Y}
\par \uldb _WClearRep\plain\fs20 {\v 1.Y.3FN}\tab \tab \tab \uldb _WScroll\plain\fs20 {\v 4133TU}
\par \uldb _WClose\plain\fs20 {\v CBE3UC}\tab \tab \tab \uldb _WScrollP\plain\fs20 {\v JZMW6V}
\par \uldb _WFindTitl\plain\fs20 {\v CM7U01}\tab \tab \tab \uldb _WSelect\plain\fs20 {\v 42WTL2}
\par \uldb _WFooter\plain\fs20 {\v 16OH7QP}\tab \tab \tab \uldb _WSendBehi\plain\fs20 {\v 1NRFAYN}
\par \pard\tx355 \uldb _WGetCurP\plain\fs20 {\v 9N6XG9}\tab \tab \tab \uldb _WSetAttr\plain\fs20 {\v 21CX3BM}
\par \uldb _WGetCurso\plain\fs20 {\v 861MMF}\tab \tab \tab \uldb _WSetPort\plain\fs20 {\v M1NZ.Z}
\par \uldb _WGetPort\plain\fs20 {\v 9NCRG_}\tab \tab \tab \uldb _WSetTitle\plain\fs20 {\v EP5QYU}
\par \uldb _WHeight\plain\fs20 {\v F.5V_B}\tab \tab \tab \uldb _WShow\plain\fs20 {\v BRJWRK}
\par \uldb _WHeightP\plain\fs20 {\v G9YL1T}\tab \tab \tab \uldb _WSize\plain\fs20 {\v BRJY29}
\par \uldb _WHide\plain\fs20 {\v 1R9WWJY}\tab \tab \tab \uldb _WSizeP\plain\fs20 {\v 1S9Z_KC}
\par \uldb _WHToHWnd\plain\fs20 {\v 20RGYZ_}\tab \tab \tab \uldb _WTitle\plain\fs20 {\v CSB8NC}
\par \uldb _WLeft\plain\fs20 {\v BRCTIH}\tab \tab \tab \tab \uldb _WTop\plain\fs20 {\v FTWTOP}
\par \uldb _WLeftP\plain\fs20 {\v CK_UVN}\tab \tab \tab \uldb _WTopP\plain\fs20 {\v BRL3SD}
\par \uldb _WMainWind\plain\fs20 {\v EW3BSD}\tab \tab \tab \uldb _WWidth\plain\fs20 {\v CVASVF}
\par \uldb _WMove\plain\fs20 {\v BRE3Y9}\tab \tab \tab \uldb _WWidthP\plain\fs20 {\v 86P8PY}
\par \uldb _WMoveP\plain\fs20 {\v CLH0GN}\tab \tab \tab \uldb _WZoom\plain\fs20 {\v BRR3RA}
\par \uldb _WOnTop\plain\fs20 {\v CNG8QN}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0009}
{\up $}{\footnote\pard\plain{\up $} Misc Functions}
{\up #}{\footnote\pard\plain{\up #} FTMISC}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} Miscellaneous Functions}
\b Miscellaneous Functions
\par \pard \uldb \plain\uldb\fs20 CallFN\plain\fs20 {\v 211_Z8Q}
\par \uldb FoxToolVer\plain\fs20 {\v 31VC9DH}
\par \uldb GetFileVersion\plain\fs20 {\v IP6OP8}
\par \uldb GetProStrg\plain\fs20 {\v 19B.QHP}
\par \uldb MainHwnd\plain\fs20 {\v 18_H6X8}
\par \uldb MsgBox\plain\fs20 {\v 1I9WPUK}
\par \uldb RegFN\plain\fs20 {\v BM.VIB}
\par \uldb RegFN32\plain\fs20 {\v BM.VIB}
\par \uldb PutProStrg\plain\fs20 {\v XDITBE}
\par \uldb RGBComp\plain\fs20 {\v WX9ZQ_}
\par 
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:000a}
{\up $}{\footnote\pard\plain{\up $} _EdActive}
{\up #}{\footnote\pard\plain{\up #} A7FFBK}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _EdActive;insertion point;range}
\b _EdActive( )
\par \pard \plain\fs20 
\par Hides or displays the insertion point or selected range in a file.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b llresult = _EdActive(nWhandle, lShow)
\par \plain\fs20 
\par \f2\b nWhandle\plain\i\fs20 
\par 
\par \plain\fs20 The whandle of the window containing the highlighted text.
\par 
\par \f2\b lShow\plain\i\fs20 
\par 
\par \plain\fs20 The show state. .F. hides, .T. displays.
\par 
\par \b Returns\plain\fs20 
\par 
\par Logical
\par 
\par \b Remarks\plain\fs20 
\par 
\par Tests with an open text file produced no changes in the display.
\par 
\par \b See Also\plain\fs20  \f251 \'96\f11  \uldb Invalid whandles\plain\fs20 {\v 0ZFR8E}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:000b}
{\up $}{\footnote\pard\plain{\up $} _EdCloseFi}
{\up #}{\footnote\pard\plain{\up #} 11I9_ZG}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _EdCloseFi;Close File}
\b _EdCloseFi( )
\par \pard\tx355 \plain\fs20 
\par Closes the specified edited file and the window displaying it.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b lnresult = _EdCloseFi(nWhandle, nCloseCmnd)
\par \plain\fs20 
\par \f2\b nWhandle\plain\i\fs20 
\par 
\par \plain\fs20 The whandle of the window containing the text.
\par 
\par \f2\b nCloseCmnd\plain\i\fs20 
\par 
\par \plain\fs20 One of three possible values, as shown in the table below.
\par 
\par \b nCloseCmnd\tab \tab Result
\par \plain\fs20 0\tab \tab \tab \tab Immediately save the file and close.
\par 1\tab \tab \tab \tab Save and close after confirmation.
\par 2\tab \tab \tab \tab Open Save As dialog.
\par 
\par \b Returns\plain\fs20 
\par 
\par \pard\tx355 Numeric
\par \pard\tx355 
\par \pard\tx355 \b Remarks\plain\fs20 
\par \pard\tx355 
\par \pard\tx355 0 is returned if the file is successfully saved. -1 is returned if the file is not saved. 1 is returned if the operation is canceled.
\par \pard\tx355 
\par \pard\tx355 \b See Also\plain\fs20  - \uldb _EdOpenFil\plain\fs20 {\v 90RGOG}, \uldb Invalid whandles\plain\fs20 {\v 0ZFR8E}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:000c}
{\up $}{\footnote\pard\plain{\up $} _EdComment}
{\up #}{\footnote\pard\plain{\up #} 367W.RW}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _EdComment;comment}
\b _EdComment( )
\par \pard \plain\fs20 
\par Inserts comment marks in highlighted text area.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b llresult = _EdComment(nWhandle, nNumberMarks)\plain\i\fs20 
\par \plain\fs20 
\par \f2\b nWhandle\plain\i\fs20 
\par 
\par \plain\fs20 The whandle of the window containing the highlighted text.
\par 
\par \f2\b nNumberMarks\plain\fs20 
\par 
\par The number of comment marks to insert per line. Format of comments marks can be made by entering or editing a value for the following key:
\par 
\par HKEY_CURRENT_USER\'5cSoftware\'5cMicrosoft\'5cVisualFoxPro\'5c6.0\'5cOptions\'5cEditorCommentString
\par 
\par \b Returns\plain\fs20 
\par \pard 
\par Logical
\par 
\par \b See Also\plain\fs20  - \uldb Invalid whandles\plain\fs20 {\v 0ZFR8E}
\par 
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:000d}
{\up $}{\footnote\pard\plain{\up $} _EdCopy}
{\up #}{\footnote\pard\plain{\up #} 1C.3RW}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _EdCopy;Copy}
\b _EdCopy( )
\par \pard \plain\fs20 
\par Copies the selected text into the clipboard.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b llresult = _EdCopy(nWhandle)
\par \plain\fs20 
\par \f2\b nWhandle\plain\i\fs20 
\par 
\par \plain\fs20 The whandle of the window containing the highlighted text.
\par 
\par \b Returns\plain\fs20 
\par 
\par Logical
\par 
\par \b Remarks\plain\fs20 
\par 
\par Normally actions associated with the clipboard require that a series of functions be called. \b EdCopy()\plain\fs20 , however, does not require this.
\par 
\par \b See Also\plain\fs20  - \uldb _EdCut\plain\fs20 {\v 14IGRDX}, \uldb _EdDelete\plain\fs20 {\v 8JRM.W4}, \uldb _EdPaste\plain\fs20 {\v 468VNP}, \uldb Invalid whandles\plain\fs20 {\v 0ZFR8E}
\par \pard 
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:000e}
{\up $}{\footnote\pard\plain{\up $} _EdCut}
{\up #}{\footnote\pard\plain{\up #} 14IGRDX}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _EdCut;Cut}
\b _EdCut( )
\par \pard \plain\fs20 
\par Cuts the highlighted text and places it in the clipboard. It is then removed from the editing window.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b llresult = _EdCut(nWhandle)
\par \plain\i\fs20 
\par \plain\f2\b\fs20 nWhandle\plain\i\fs20 
\par 
\par \plain\fs20 The whandle of the window containing the highlighted text.
\par 
\par \b Returns\plain\fs20 
\par 
\par Logical
\par 
\par \b See Also\plain\fs20  - \uldb _EdCopy\plain\fs20 {\v 1C.3RW}, \uldb _EdDelete\plain\fs20 {\v 8JRM.W4}, \uldb _EdPaste\plain\fs20 {\v 468VNP}, \uldb Invalid whandles\plain\fs20 {\v 0ZFR8E}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:000f}
{\up $}{\footnote\pard\plain{\up $} _EdDelete}
{\up #}{\footnote\pard\plain{\up #} 8JRM.W4}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _EdDelete;Delete}
\b _EdDelete( )
\par \pard \plain\fs20 
\par Deletes the highlighted text from the file. While the API documentation states that if no text is selected, the character to the right of the current cursor position is deleted, the FOXTOOLS version does not do this.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b llresult = _EdDelete(nWhandle)
\par 
\par nWhandle
\par \plain\i\fs20 
\par \plain\fs20 The whandle of the window containing the highlighted text.
\par 
\par \b Returns\plain\fs20 
\par 
\par Logical
\par 
\par \b See Also\plain\fs20  - \uldb _EdCopy\plain\fs20 {\v 1C.3RW}, \uldb _EdCut\plain\fs20 {\v 14IGRDX}, \uldb _EdPaste\plain\fs20 {\v 468VNP}, \uldb Invalid whandles\plain\fs20 {\v 0ZFR8E}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0010}
{\up $}{\footnote\pard\plain{\up $} _EdGetChar}
\pard\keepn\sb235\sa55 {\up #}{\footnote\pard\plain{\up #} 57VD36}
{\up K}{\footnote\pard\plain{\up K} _EdGetChar;character}
\b _EdGetChar( )
\par \pard \plain\fs20 
\par Returns the character at a position within the file.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b lcresult = _EdGetChar(nWhandle, nPosition)
\par 
\par nWhandle
\par \plain\fs20 
\par The whandle of the file containing the text
\par 
\par \f2\b nPosition\plain\fs20 
\par 
\par The position in bytes from the beginning of the file. To retrieve the current cursor position use \uldb \b _EdGetPos\plain\b\fs20 {\v 3X.WJZS}\plain\fs20 .
\par 
\par \b Returns\plain\fs20 
\par 
\par Character
\par 
\par \b Example\plain\fs20 
\par 
\par The following uses \b _EdGetChar()\plain\fs20  to retrieve the character at the current cursor position. This value is retrieved using the \uldb \b _EdGetPos\plain\b\fs20 {\v 3X.WJZS}\plain\fs20  function.
\par \pard 
\par \f2\b * lctitle is the title text of the window
\par * containing the file being edited.
\par lnwhandle = _WFindTitl(lctitle)
\par IF lnwhandle > 0
\par   lnindex = _EdGetPos(lnwhandle)
\par   lcresult = _EdGetChar(lnwhandle, lnindex)
\par ENDIF
\par \plain\fs20 
\par \b See Also\plain\fs20  -\uldb _EdGetPos\plain\fs20 {\v 3X.WJZS}, \uldb Invalid whandles\plain\fs20 {\v 0ZFR8E}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0011}
{\up $}{\footnote\pard\plain{\up $} _EdGetEnv}
{\up #}{\footnote\pard\plain{\up #} 19BRARA}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _EdGetEnv;environment}
\b _EdGetEnv( )
\par \pard \plain\fs20 
\par Returns the environment settings for a text or program file opened for editing.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b lnresult = _EdGetEnv(nWhandle, @aEnvironment)
\par \plain\fs20 
\par \f2\b nWhandle\plain\fs20 
\par 
\par The whandle of the file containing the text
\par 
\par \f2\b aEnvironment\plain\fs20 
\par 
\par An array to hold the environment settings. This array should first be dimensioned to at least 25 rows and must be passed by reference.
\par 
\par \b Returns\plain\fs20  
\par 
\par Numeric
\par 
\par \b Remarks\plain\fs20 
\par 
\par The function will return 1 if it succeeds in loading the array, 0 if it does not. The return values for the array rows are listed in the following table. Those elements whose description are followed by an asterisk may be modified and changed by using \uldb \b _EdSetEnv\plain\b\fs20 {\v 1EBRARA}\plain\fs20 .
\par \pard\tx355 
\par \b Array Subscript\tab Return Value\plain\fs20 
\par 1\tab \tab \tab \tab File name
\par 2\tab \tab \tab \tab File size
\par 3\tab \tab \tab \tab Maximum file size (0 = infinite)*
\par 4\tab \tab \tab \tab Changed state (0 = No, 1 = Yes)
\par 5\tab \tab \tab \tab Auto Indent? (0 = No, 1 = Yes)*
\par 6\tab \tab \tab \tab Make backup? (0 = No, 1 = Yes)*
\par 7\tab \tab \tab \tab Add Linefeeds when saved (0 = No, 1 = Yes)*
\par 8\tab \tab \tab \tab Auto-compile? (0 = No, 1 = Yes)*
\par 9\tab \tab \tab \tab Add Cntrl+Z at end of file? (0 = No, 1 = Yes)*
\par 10\tab \tab \tab \tab Save preferences? (0 = No, 1 = Yes)*
\par 11\tab \tab \tab \tab Allow Drag/Drop? (0 = No, 1 = Yes)*
\par \pard\tx355 12\tab \tab \tab \tab Read-Only?
\par \pard\li2155\tx355 (0 = No, 1 = Yes, 2 = Read/Write opened as read-only, 3 = Read-Only  opened as read-only)
\par \pard\tx355 13\tab \tab \tab \tab Display Status Bar? (0 = No, 1 = Yes)*
\par 14\tab \tab \tab \tab Update preferences? (0 = No, 1 = Yes)*
\par 15\tab \tab \tab \tab Insert Mode? (0 = No, 1 = Yes)*
\par 16\tab \tab \tab \tab Wrap Words? If less than 0, new line at return only.*
\par 17\tab \tab \tab \tab Selection Start
\par 18\tab \tab \tab \tab Selection End
\par 19\tab \tab \tab \tab Selection Anchor point
\par 20\tab \tab \tab \tab Justification (0 = Left, 1 = Right, 2 = Center)*
\par 21\tab \tab \tab \tab Tab size in spaces*
\par 22\tab \tab \tab \tab Font name*
\par 23\tab \tab \tab \tab Font size*
\par 24\tab \tab \tab \tab Font style (0 = plain, 1 = bold, 2 = italic, 3 = bold italic)*
\par \pard\tx355 25\tab \tab \tab \tab Editor Session \f251 \'96\f11  The editor session is as follows:
\par \tab \tab \tab \tab 0 \f251 \'96\f11  Command Window
\par \pard\li1435\fi715\tx355 1 \f251 \'96\f11  Program file (MODIFY COMMAND)
\par \pard\li1435\fi715\tx355 2 \f251 \'96\f11  Text Editor (MODIFY FILE)
\par \pard\li1435\fi715\tx355 8 \f251 \'96\f11  Menu code edit window
\par \pard\li1435\fi715\tx355 10 \f251 \'96\f11  Method code edit window of the Class or Form Designer
\par \pard\li1435\fi715\tx355 12 \f251 \'96\f11  Stored procedure in a DBC (MODIFY PROCEDURE)
\par \pard\tx355 
\par \pard\tx355 The values for the last element of the array are correct for versions 5.0 and 6.0. Prior versions have not, as yet, been tested.
\par \pard\tx355 
\par \pard\tx355 Unfortunately, in version 6.0, the function does not return the correct information regarding the font name, its size or style. In order to do so, the following code, based on the work of Christof Lange, will accomplish this and return the values listed above. In FPW 2.6, the information returned from the function is correct.
\par \pard\tx355 
\par \pard\tx355 \f2\b * Sample Call
\par \pard\tx355 lnwhandle = _WFindTitl(\f251 \'91\f2 program1.pgr\f251 \'92\f2 )
\par \pard\tx355 lcname = \'93\'94
\par \pard\tx355 STORE 0 TO lnsize, lnstyle
\par \pard\tx355 IF GetFontInfo(lnwhandle, @lcname, @lnsize, @lnstyle)
\par \pard\tx355   ? lcname
\par \pard\tx355   ? lnsize
\par \pard\tx355   ? lnstyle
\par \pard\tx355 ENDIF
\par \pard\tx355 
\par \pard\tx355 FUNCTION GetFontInfo
\par \pard\tx355 * Author: George Tasker
\par \pard\tx355 * Date: June 11, 2000 - 6:46 PM
\par \pard\tx355 * Purpose: Returns font information
\par \pard\tx355 * from the editor window
\par \pard\tx355 * The comments below are from Christof
\par \pard\tx355 * Lange (with those from me indicated),
\par \pard\tx355 * whose original code is the source
\par \pard\tx355 * of this function
\par \pard\tx355 
\par \pard\tx355   LPARAMETERS twHandle, tcFontName, tnFontSize, tnFontStyle
\par \pard\tx355   
\par \pard\tx355   LOCAL lresult, lnhWnd, lnHDC, lnHFont,;
\par \pard\tx355     lnsize, lcbuffer
\par \pard\tx355   #DEFINE OBJ_FONT 6
\par \pard\tx355   llresult = .F.
\par \pard\tx355   *-----------------------------------------------------------------
\par \pard\tx355   * We don't need the window handle of this window, but we need
\par \pard\tx355   * the HWND of the child window that contains the actual editor.
\par \pard\tx355   * The GetClientWindow() function retrieves this window handle.
\par \pard\tx355   *-----------------------------------------------------------------
\par \pard\tx355   lnhWnd = GetClientWindow(twHandle)
\par \pard\tx355   IF lnhWnd > 0
\par \pard\tx355     *--------------------------------------------------
\par \pard\tx355     * Using this HWND we can then get a Device Context.
\par \pard\tx355     *--------------------------------------------------
\par \pard\tx355     DECLARE INTEGER GetDC IN Win32API;
\par \pard\tx355      INTEGER hwnd
\par \pard\tx355     lnHDC = GetDC(lnhWnd)
\par \pard\tx355     IF lnHDC > 0
\par \pard\tx355       *-------------------------------------------------
\par \pard\tx355       * With this device context we can now get 
\par \pard\tx355       * an object handle to the currently selected font.
\par \pard\tx355       *-------------------------------------------------
\par \pard\tx355       DECLARE INTEGER GetCurrentObject IN Win32API;
\par \pard\tx355         INTEGER hdc, INTEGER uObjectType
\par \pard\tx355       lnHFont = GetCurrentObject(lnHDC, OBJ_FONT)
\par \pard\tx355       IF lnHFont > 0
\par \pard\tx355         *-----------------------------------------------------
\par \pard\tx355         * The HFONT handle to the current font can be
\par \pard\tx355         * used to obtain more detailed information about the 
\par \pard\tx355         * selected font. 
\par \pard\tx355         * We need to rename the API function GetObject(), 
\par \pard\tx355         * because it's the same as VFP's GETOBJECT() function
\par \pard\tx355         *-----------------------------------------------------
\par \pard\tx355         DECLARE INTEGER GetObject IN Win32API AS GDIGetObject;
\par \pard\tx355           INTEGER hgdiobj, INTEGER cbbuffer, STRING @lpvObject
\par \pard\tx355         lnsize = GDIGetObject(lnHFont, 0, 0)
\par \pard\tx355         lcbuffer = REPLICATE(CHR(0), lnsize)
\par \pard\tx355         IF GDIGetObject(lnHFont, lnsize, @lcbuffer) > 0
\par \pard\tx355           *----------------------------------------------------
\par \pard\tx355           * Now we can extract the font information from the
\par \pard\tx355           * LOGFONT structure.
\par \pard\tx355           *---------------------------------------------------- 
\par \pard\tx355           llresult = .T.
\par \pard\tx355           tcFontName = SUBSTR(lcbuffer, 29)
\par \pard\tx355           tcFontName = LEFT(tcFontName, AT(CHR(0), tcFontName) - 1)
\par \pard\tx355           tnFontSize = ABS(StringToInteger(LEFT(lcbuffer, 4), .T.))
\par \pard\tx355           * Convert the pixels to points - gt
\par \pard\tx355           tnFontSize = Pix2Points(lnHDC, tnFontSize)
\par \pard\tx355           tnFontStyle = 0
\par \pard\tx355           IF StringToInteger(SUBSTR(lcbuffer, 17, 4)) >= 700
\par \pard\tx355             tnFontStyle = tnFontStyle + 1
\par \pard\tx355           ENDIF
\par \pard\tx355           IF ASC(SUBSTR(lcbuffer, 21, 1)) # 0
\par \pard\tx355             tnFontStyle = tnFontStyle + 2
\par \pard\tx355           ENDIF
\par \pard\tx355         ENDIF
\par \pard\tx355       ENDIF
\par \pard\tx355       DECLARE INTEGER ReleaseDC IN Win32API;
\par \pard\tx355         INTEGER hwnd, INTEGER hdc
\par \pard\tx355       * Release the Device Context - gt
\par \pard\tx355       = ReleaseDC(lnhWnd, lnHDC)
\par \pard\tx355     ENDIF
\par \pard\tx355   ENDIF
\par \pard\tx355   RETURN llresult
\par \pard\tx355 ENDFUNC
\par \pard\tx355 
\par \pard\tx355 FUNCTION GetClientWindow
\par \pard\tx355 
\par \pard\tx355   LPARAMETER tnwHandle
\par \pard\tx355   
\par \pard\tx355   LOCAL lnresult, lnhwnd, lnchild
\par \pard\tx355   DECLARE INTEGER GetWindow IN Win32API;
\par \pard\tx355     INTEGER hwnd, INTEGER uCmd
\par \pard\tx355   #DEFINE GW_HWNDNEXT 2
\par \pard\tx355   #DEFINE GW_CHILD 5
\par \pard\tx355   lnresult = 0
\par \pard\tx355   lnhwnd = _WhTohWnd(tnwHandle)
\par \pard\tx355   IF lnhwnd > 0
\par \pard\tx355     lnhwnd = GetWindow(lnhwnd, GW_CHILD)
\par \pard\tx355     DO WHILE lnhwnd > 0
\par \pard\tx355       lnresult = lnhwnd
\par \pard\tx355       lnhwnd = GetWindow(lnhwnd, GW_HWNDNEXT)
\par \pard\tx355     ENDDO
\par \pard\tx355   ENDIF
\par \pard\tx355   RETURN lnresult
\par \pard\tx355 ENDFUNC
\par \pard\tx355 
\par \pard\tx355 FUNCTION Pix2Points
\par \pard\tx355 
\par \pard\tx355   LPARAMETERS tnHDC, tnPixels
\par \pard\tx355   
\par \pard\tx355   LOCAL lnresult, lnresolution
\par \pard\tx355   DECLARE INTEGER GetDeviceCaps IN Win32API;
\par \pard\tx355     INTEGER hdc, INTEGER nIndex
\par \pard\tx355   lnresolution = GetDeviceCaps(tnHDC, 90)
\par \pard\tx355   lnresult = tnPixels / lnresolution * 72
\par \pard\tx355   lnresult = ROUND(lnresult, 0)
\par \pard\tx355   RETURN lnresult
\par \pard\tx355 ENDFUNC
\par \pard\tx355 
\par \pard\tx355 FUNCTION StringToInteger
\par \pard\tx355     
\par \pard\tx355   LPARAMETER pcstring, plsigned
\par \pard\tx355     
\par \pard\tx355   LOCAL lnresult, lnlast, lni, llsigned,;
\par \pard\tx355     lnmsb, lnmax
\par \pard\tx355   lnresult = 0
\par \pard\tx355   lnlast = LEN(pcstring)
\par \pard\tx355   * Return Signed Integer?
\par \pard\tx355   IF PCOUNT() = 2
\par \pard\tx355     llsigned = plsigned
\par \pard\tx355   ELSE
\par \pard\tx355     llsigned = .F.
\par \pard\tx355   ENDIF
\par \pard\tx355   FOR lni = 1 TO lnlast
\par \pard\tx355     lnresult = lnresult + ASC(SUBSTR(pcstring, lni, 1)) * (256 ^ (lni - 1))
\par \pard\tx355   NEXT
\par \pard\tx355   IF llsigned
\par \pard\tx355     lnmsb = (lnlast * 8) - 1
\par \pard\tx355     IF BITTEST(lnresult, lnmsb)
\par \pard\tx355       lnmax = (2 ^ (lnmsb + 1))
\par \pard\tx355       lnresult = lnresult - lnmax
\par \pard\tx355     ENDIF
\par \pard\tx355   ENDIF
\par \pard\tx355   RETURN lnresult
\par \pard\tx355 ENDFUNC
\par \pard\tx355 
\par \pard\tx355 \f11 See Also\plain\fs20  \uldb _EdSetEnv\plain\fs20 {\v 1EBRARA}, \uldb Invalid whandles\plain\fs20 {\v 0ZFR8E}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0012}
{\up $}{\footnote\pard\plain{\up $} _EdGetLNum}
{\up #}{\footnote\pard\plain{\up #} 584JG1}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _EdGetLNum;Line Number}
\b _EdGetLNum( )
\par \pard \plain\fs20 
\par Returns the line number the cursor is currently positioned at.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b lnlinenum = _EdGetLNum(nWhandle, nPosition)
\par \plain\fs20 
\par \f2\b nWhandle\plain\fs20 
\par 
\par The whandle of the window containing the text
\par 
\par \f2\b nPosition\plain\fs20 
\par 
\par The position in bytes from the beginning of the file.
\par 
\par \b Returns\plain\fs20 
\par 
\par Numeric
\par 
\par \b Remarks\plain\fs20 
\par 
\par The value returned is zero based. Add 1 to this value for the current line number. If the text is highlighted and the carriage return is included in the highlight, the value is one greater than the actual line number.
\par \pard 
\par Both this function and \uldb _EdGetLPos\plain\fs20 {\v 584LA7} scans text from the beginning of the text in the specified window. 
\par 
\par \b See Also\plain\fs20  - \uldb _EdGetPos\plain\fs20 {\v 3X.WJZS}, \uldb Invalid whandles\plain\fs20 {\v 0ZFR8E}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0013}
{\up $}{\footnote\pard\plain{\up $} _EdGetLPos}
{\up #}{\footnote\pard\plain{\up #} 584LA7}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _EdGetLPos;Line Number}
\b _EdGetLPos( )
\par \pard \plain\fs20 
\par Returns the offset (in bytes) of the beginning of a specified line from the start of the file.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b lnbytes = _EdGetLPos(nWhandle, nLineNo)
\par \plain\fs20 
\par \f2\b nWhandle\plain\fs20 
\par 
\par The whandle of the program or editing window containing the text.
\par 
\par \f2\b nLineNo\plain\fs20 
\par 
\par The line number (0 based).
\par 
\par \b Returns\plain\fs20 
\par 
\par Numeric
\par 
\par \b See Also\plain\fs20  - \uldb _EdGetLNum\plain\fs20 {\v 584JG1}, \uldb Invalid whandles\plain\fs20 {\v 0ZFR8E}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0014}
{\up $}{\footnote\pard\plain{\up $} _EdGetPos}
{\up #}{\footnote\pard\plain{\up #} 3X.WJZS}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _EdGetPos;Starting Position}
\b _EdGetPos( )
\par \pard \plain\fs20 
\par Returns the starting position of either the selected text or insertion position in bytes from the beginning of the file.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b lnposition = _EdGetPos(nwhandle)
\par 
\par nWhandle
\par \plain\i\fs20 
\par \plain\fs20 The whandle of the window containing the highlighted text.
\par \i 
\par \plain\b\fs20 Returns\plain\fs20 
\par 
\par Numeric
\par 
\par \b Remarks\plain\fs20 
\par 
\par The starting position is the point from which the highlight began (the anchor position) and may or may not be the earliest highlighted position. Clicking and dragging to the left, for example, will cause the anchor to be set at the end point of the highlight, and will be the value returned.
\par \pard 
\par \b See Also\plain\fs20  - \uldb _EdGetLNum\plain\fs20 {\v 584JG1}, \uldb _EdGetChar\plain\fs20 {\v 57VD36}, \uldb _EdSetPos\plain\fs20 {\v 3G3KKCC}, \uldb Invalid whandles\plain\fs20 {\v 0ZFR8E}\i 
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0015}
{\up $}{\footnote\pard\plain{\up $} _EdGetStr}
{\up #}{\footnote\pard\plain{\up #} 19BROX_}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _EdGetStr;String}
\plain\b\fs20 _EdGetStr( )
\par \pard \plain\fs20 
\par Returns a specified number of characters beginning at a specified position within the file.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b lcresult = _EdGetStr(nWhandle, nStart, nFinish)
\par 
\par nWhandle
\par \plain\fs20 
\par The whandle of the window containing the text.
\par 
\par \f2\b nStart\plain\fs20 
\par 
\par The starting position within the file to begin the retrieve. The character at this position is the first retrieved.
\par 
\par \f2\b nFinish\plain\fs20 
\par 
\par The position to stop retrieving characters.
\par 
\par \b Returns\plain\fs20 
\par 
\par Character
\par 
\par \b See Also\plain\fs20  - \uldb Invalid whandles\plain\fs20 {\v 0ZFR8E}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0016}
{\up $}{\footnote\pard\plain{\up $} _EdIndent}
{\up #}{\footnote\pard\plain{\up #} IB6B0Z}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _EdIndent;Indent}
\b _EdIndent( )
\par \pard \plain\fs20 
\par Indents text one or more tab stops, beginning at the current insertion point.
\par 
\par \b Syntax
\par 
\par \f2 llresult = _EdIndent(nWhandle, nTabStops)
\par 
\par nWhandle
\par \plain\i\fs20 
\par \plain\fs20 The whandle of the window containing the text to indent.
\par 
\par \f2\b nTabStops\plain\i\fs20 
\par 
\par \plain\fs20 The number of tab stops to indent the text. Passing a negative number un-indents the text the number of tab stops specified.
\par 
\par \b Return Type
\par 
\par \plain\fs20 Logical
\par 
\par \b See Also\plain\fs20  - \uldb Invalid whandles\plain\fs20 {\v 0ZFR8E}\b 
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0017}
{\up $}{\footnote\pard\plain{\up $} _EdInsert}
{\up #}{\footnote\pard\plain{\up #} 1XU2ABO}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _EdInsert;Insert}
_EdInsert( )
\par \pard \plain\fs20 
\par Inserts text at the current position within a text or program file opened for editing.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b llresult = _EdInsert(nWhandle, cInserttext, nNumberChars)
\par \plain\fs20 
\par \f2\b nWhandle\plain\i\fs20 
\par 
\par \plain\fs20 The whandle of the window.
\par 
\par \f2\b cInserttext\plain\i\fs20 
\par \plain\fs20 
\par The text to insert.
\par 
\par \f2\b nNumberChars\plain\fs20 
\par 
\par The length of the text to be inserted.
\par 
\par \b Returns\plain\fs20 
\par 
\par Logical
\par 
\par \b See Also\plain\fs20  - \uldb Invalid whandles\plain\fs20 {\v 0ZFR8E}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0018}
{\up $}{\footnote\pard\plain{\up $} _EdLastErr}
{\up #}{\footnote\pard\plain{\up #} XUJD8W}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _EdLastErr;Edit Errors}
\b _EdLastErr( )
\par \pard \plain\fs20 
\par Returns the error number when an error occurs.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b lnerr = _EdLastErr(nWhandle)
\par \plain\i\fs20 
\par \plain\f2\b\fs20 nWhandle\plain\i\fs20 
\par 
\par \plain\fs20 The whandle of the text/program edit window.
\par 
\par \b Returns\plain\fs20 
\par 
\par Numeric
\par 
\par \b Remarks\plain\fs20 
\par 
\par Unfortunately, the return values are unknown at this time.
\par 
\par \b See Also\plain\fs20  - \uldb Invalid whandles\plain\fs20 {\v 0ZFR8E}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0019}
{\up $}{\footnote\pard\plain{\up $} _EdOpenFil}
{\up #}{\footnote\pard\plain{\up #} 90RGOG}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _EdOpenFil;Open;Open File}
\b _EdOpenFil( )
\par \pard\tx355 \plain\fs20 
\par Opens a file for reading or editing.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b lnwhandle = _EdOpenFil(cFilename, nMode)
\par \plain\i\fs20 
\par \plain\f2\b\fs20 cFilename\plain\i\fs20 
\par 
\par \plain\fs20 The fully qualified file name to open.
\par \i 
\par \plain\f2\b\fs20 nMode\plain\i\fs20 
\par 
\par \plain\fs20 The mode the file is opened in. This can be one of the following values:
\par 
\par #DEFINE FO_READONLY\tab 0
\par #DEFINE FO_WRITEONLY\tab 1
\par #DEFINE FO_READWRITE\tab 2
\par 
\par \b Returns\plain\fs20 
\par 
\par Numeric
\par 
\par \b Remarks\plain\fs20 
\par 
\par The value returned is the whandle of the opened window. If the file does not exist the window will be created with the file name as the title.
\par \pard\tx355 
\par \b See Also\plain\fs20  - \uldb _EdCloseFi\plain\fs20 {\v 11I9_ZG}, \uldb Invalid whandles\plain\fs20 {\v 0ZFR8E}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:001a}
{\up $}{\footnote\pard\plain{\up $} _EdPaste}
{\up #}{\footnote\pard\plain{\up #} 468VNP}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _EdPaste;Paste}
\b _EdPaste( )
\par \pard \plain\fs20 
\par Pastes the contents of the clipboard into the window at the current insertion point.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b llresult = _EdPaste(nWhandle)
\par 
\par nWhandle
\par \plain\fs20 
\par The whandle of the window opened for editing.
\par 
\par \b Returns\plain\fs20 
\par 
\par Logical
\par 
\par \b See Also\plain\fs20  - \uldb _EdCopy\plain\fs20 {\v 1C.3RW}, \uldb _EdCut\plain\fs20 {\v 14IGRDX}, \uldb _EdDelete\plain\fs20 {\v 8JRM.W4}, \uldb Invalid whandles\plain\fs20 {\v 0ZFR8E}
\par 
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:001b}
{\up $}{\footnote\pard\plain{\up $} _EdPosInvi}
{\up #}{\footnote\pard\plain{\up #} 18HMP1D}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _EdPosInvi}
\b _EdPosInvi( )
\par \pard \plain\fs20 
\par Tells whether or not the insertion position within the file is currently displayed.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b llresult = _EdPosInvi(nWhandle, nPosition)
\par 
\par nWhandle
\par \plain\fs20 
\par The whandle of the open editing window.
\par 
\par \f2\b nPosition\plain\fs20 
\par 
\par The position in the file in bytes.
\par 
\par \b Returns\plain\fs20 
\par 
\par Logical
\par 
\par \b See Also\plain\fs20  - \uldb Invalid whandles\plain\fs20 {\v 0ZFR8E}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:001c}
{\up $}{\footnote\pard\plain{\up $} _EdProperties}
{\up #}{\footnote\pard\plain{\up #} 12T4H7T}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _EdProperties;Properties Dialog}
\b _EdProperties( )
\par \pard \plain\fs20 
\par Displays an Edit Properties dialog formatted for the particular editing window.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b llresult = _EdProperties(nWhandle)
\par 
\par nWhandle
\par \plain\fs20 
\par The whandle of the editing window.
\par 
\par \b Returns\plain\fs20 
\par 
\par Logical
\par 
\par \b Remarks\plain\fs20 
\par 
\par Regardless of the action taken, this function always returns .T.
\par 
\par \b See Also\plain\fs20  - \uldb Invalid whandles\plain\fs20 {\v 0ZFR8E}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:001d}
{\up $}{\footnote\pard\plain{\up $} _EdProcList}
{\up #}{\footnote\pard\plain{\up #} RELHQC}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _EdProcList;Procedure/Function Dialog}
\b _EdProcList( )
\par \pard \plain\fs20 
\par Invokes the procedure/function list dialog.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b llresult = _EdProcList(nWhandle)
\par 
\par nWhandle
\par \plain\fs20 
\par The whandle of the program file being edited.
\par 
\par \b Returns\plain\fs20 
\par 
\par Logical
\par 
\par \b Remarks\plain\fs20 
\par 
\par Regardless of the action taken, this function always returns .T. Calling this function with an inappropriate value may cause VFP to generate a General Protection Fault.
\par 
\par \b See Also\plain\fs20  - \uldb Invalid whandles\plain\fs20 {\v 0ZFR8E}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:001e}
{\up $}{\footnote\pard\plain{\up $} _EdRedo}
{\up #}{\footnote\pard\plain{\up #} 1CJTFM}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _EdRedo;Redo}
\b _EdRedo( )
\par \pard \plain\fs20 
\par Repeats the last action cancelled by _EdUndo().
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b llresult = _EdRedo(nWhandle)
\par 
\par nWhandle
\par 
\par \plain\fs20 The whandle of the editing window.
\par 
\par \b Returns\plain\fs20 
\par 
\par Logical
\par 
\par \b Remarks\plain\fs20 
\par 
\par This function always returns .T.
\par 
\par \b See Also\plain\fs20  - \uldb _EdUndo\plain\fs20 {\v 1CN2FM}, \uldb _EdUndoOn\plain\fs20 {\v 88ULOD}, \uldb Invalid whandles\plain\fs20 {\v 0ZFR8E}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:001f}
{\up $}{\footnote\pard\plain{\up $} _EdRevert}
{\up #}{\footnote\pard\plain{\up #} 26L5ABO}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _EdRevert;Revert}
\b _EdRevert( )
\par \pard \plain\fs20 
\par Discards all changes made to the file displaying in the editing window since it was most recently saved.
\par 
\par \b Syntax
\par 
\par \f2 llresult = _EdRevert(nWhandle)
\par 
\par nWhandle
\par \plain\fs20 
\par The whandle of the editing window.
\par 
\par \b Returns\plain\fs20 
\par 
\par Logical
\par 
\par \b Remarks\plain\fs20 
\par 
\par Regardless of the setting of SET SAFETY, this function displays a dialog asking if the changes are to be discarded. Function always returns .T.
\par 
\par \b See Also\plain\fs20  - \uldb Invalid whandles\plain\fs20 {\v 0ZFR8E}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0020}
{\up $}{\footnote\pard\plain{\up $} _EdSelect}
{\up #}{\footnote\pard\plain{\up #} 27KVA3O}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _EdSelect;range;select}
\b _EdSelect( )
\par \pard \plain\fs20 
\par Selects a range in the specified editing window.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b llresult = _EdSelect(nWhandle, nStart, nStop)
\par 
\par nWhandle
\par \plain\fs20 
\par The whandle of the editing window.
\par 
\par \f2\b nStart
\par \plain\fs20 
\par The starting point in bytes to begin the selection. Zero based.
\par 
\par \f2\b nStop\plain\fs20 
\par 
\par The ending point in bytes of the selection. This point is included in the range selected.
\par 
\par \b Returns\plain\fs20 
\par 
\par Logical
\par 
\par \b Remarks\plain\fs20 
\par 
\par This function always returns .T. To unselect a range, pass the same values as starting and ending points.
\par \pard 
\par \b See Also\plain\fs20  - \uldb Invalid whandles\plain\fs20 {\v 0ZFR8E}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0021}
{\up $}{\footnote\pard\plain{\up $} _EdSendKey}
{\up #}{\footnote\pard\plain{\up #} 3.0.M4D}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _EdSendKey;key press}
\b _EdSendKey( )
\par \pard \plain\fs20 
\par Simulates a keypress in the specified text or program editing window. The corresponding ASCII character is displayed at the current insertion point.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b llresult = _EdSendKey(nWhandle, nKeyPress)
\par 
\par nWhandle
\par 
\par \plain\fs20 The whandle of the editing window.
\par 
\par \f2\b nKeyPress
\par \plain\fs20 
\par The ASCII value of the key to send.
\par 
\par \b Returns\plain\fs20 
\par 
\par Logical
\par 
\par \b Remarks\plain\fs20 
\par 
\par This function always returns .T. 
\par 
\par \b See Also\plain\fs20  - \uldb Invalid whandles\plain\fs20 {\v 0ZFR8E}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0022}
{\up $}{\footnote\pard\plain{\up $} _EdSetEnv}
{\up #}{\footnote\pard\plain{\up #} 1EBRARA}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _EdSetEnv;environment}
\b _EdSetEnv( )
\par \pard \plain\fs20 
\par Set the environment for a text or program file opened for editing.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b lnresult = _EdSetEnv(nWhandle, @aEnvironment)
\par \plain\fs20 
\par \f2\b nWhandle\plain\fs20 
\par 
\par The whandle of the file containing the text
\par 
\par \f2\b aEnvironment\plain\fs20 
\par 
\par An array to hold the environment settings. This array should be dimensioned to at least 25 rows, and must be passed by reference.
\par 
\par \b Returns\plain\fs20  
\par 
\par Numeric
\par 
\par \b Remarks\plain\fs20 
\par 
\par The function will return 1 if it succeeds, 0 if it does not. The appropriate values for the array rows are listed in the table under the \uldb \b _EdGetEnv\plain\b\fs20 {\v 19BRARA}\plain\fs20 . topic.
\par \pard 
\par Setting some values may require that the window be re-drawn in order for the changes to be noticed. The following code snippet demonstrates how to display a file edit window with word wrap turned off. A similar technique may be required for other changes as well.
\par 
\par \f2\b * lcfile is a file to edit
\par MODIFY FILE (lcfile) NOWAIT
\par lnwhandle = _WonTop()
\par * Minimize the window
\par = _WZoom(lnwhandle, 2)
\par DIMENSION a_env[25]
\par = EdGetEnv(lnwhandle, @a_env)
\par a_env[16] = -1
\par = EdSetEnv(lnwhandle, @a_env)
\par \pard * Restore the window
\par = _WZoom(lnwhandle, 1)
\par \plain\fs20 
\par See Also - \uldb _EdGetEnv\plain\fs20 {\v 19BRARA}, \uldb Invalid whandles\plain\fs20 {\v 0ZFR8E}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0023}
{\up $}{\footnote\pard\plain{\up $} _EdSetPos}
{\up #}{\footnote\pard\plain{\up #} 3G3KKCC}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _EdSetPos;insertion point}
\b _EdSetPos( )
\par \pard \plain\fs20 
\par Sets the insertion point in the specified editing window.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b llresult = _EdSetPos(nWhandle, nPosition)
\par 
\par nWhandle
\par \plain\fs20 
\par The whandle of the editing window.
\par 
\par \f2\b nPosition
\par \plain\fs20 
\par The point, in terms of bytes, at which to set the insertion point. The position is 0 based.
\par 
\par \b Returns\plain\fs20 
\par 
\par Logical
\par 
\par \b Remarks\plain\fs20 
\par 
\par This function always returns .T.
\par 
\par \b See Also\plain\fs20  - \uldb _EdGetPos\plain\fs20 {\v 3X.WJZS}, \uldb Invalid whandles\plain\fs20 {\v 0ZFR8E}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0024}
{\up $}{\footnote\pard\plain{\up $} _EdSkipLin}
{\up #}{\footnote\pard\plain{\up #} 2OW.NKT}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _EdSkipLin;insertion point}
\b _EdSkipLin( )
\par \pard \plain\fs20 
\par Returns a new insertion point value, a specific number of lines forward or backwards from another insertion point.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b lnbytes = _EdSkipLin(nWhandle, nPosition, nLines)
\par 
\par nWhandle
\par \plain\fs20 
\par The whandle of the editing window.
\par 
\par \f2\b nPosition\plain\fs20 
\par 
\par The position, in bytes, within the file from which to move the insertion point.
\par 
\par \f2\b nLines\plain\fs20 
\par 
\par The number of lines to move forward (positive) or backward (negative).
\par 
\par \b Returns\plain\fs20 
\par 
\par Numeric
\par 
\par \b Remarks\plain\fs20 
\par \pard 
\par The value returned will be the number of bytes from the beginning of the file for the new insertion point. Use \uldb \b _EdSetPos\plain\b\fs20 {\v 3G3KKCC}\plain\fs20  set it.
\par 
\par \b See Also\plain\fs20  - \uldb _EdSetPos\plain\fs20 {\v 3G3KKCC}, \uldb Invalid whandles\plain\fs20 {\v 0ZFR8E}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0025}
{\up $}{\footnote\pard\plain{\up $} _EdStoPos}
{\up #}{\footnote\pard\plain{\up #} 2U90KW3}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _EdStoPos}
\b _EdStoPos( )
\par \pard \plain\fs20 
\par Manipulates the edit window of a program or text file so that if a position is beyond the the area shown, it is displayed.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b llresult = _EdStoPos(nWhandle, nPosition, lScroll)
\par 
\par nWhandle
\par \plain\fs20 
\par The whandle of the edit window.
\par 
\par \f2\b nPosition
\par \plain\fs20 
\par The position in the file to store.
\par 
\par \f2\b lScroll
\par \plain\fs20 
\par Whether or not the position is to be brought to a mid-point in the editing window (.T.), or the window is scrolled so that the first line containing the position is shown (.F.) as the last line in the window.
\par \pard 
\par \b Returns\plain\fs20 
\par 
\par Logical
\par 
\par \b Remarks\plain\fs20 
\par 
\par The function has no impact on the current position of the cursor or selected range. If the position is already visible, the function has no effect. However, if the position is not visible it is made so. Always returns .T.
\par 
\par \b See Also\plain\fs20  - \uldb _EdStoSel\plain\fs20 {\v SHAP1R}, \uldb Invalid whandles\plain\fs20 {\v 0ZFR8E}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0026}
{\up $}{\footnote\pard\plain{\up $} _EdStoSel}
{\up #}{\footnote\pard\plain{\up #} SHAP1R}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _EdStoSel}
\b _EdStoSel( )
\par \pard \plain\fs20 
\par Scrolls the specified editing window so that the stored position is shown.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b llresult = _EdStoSel(nWhandle, lScroll)
\par 
\par nWhandle
\par \plain\fs20 
\par The whandle of the edit window.
\par 
\par \f2\b lScroll
\par \plain\fs20 
\par Whether or not the position is to be brought to a mid-point in the editing window (.T.), or the window is scrolled so that the first line containing the position is shown (.F.) as the last line in the window.
\par 
\par \b Returns\plain\fs20 
\par 
\par Logical
\par 
\par \b Remarks\plain\fs20 
\par 
\par The position must have been stored using \uldb _\b EdStoPos\plain\b\fs20 {\v 2U90KW3}\plain\fs20 . Always returns .T.
\par \pard 
\par \b See Also\plain\fs20  - \uldb _EdStoPos\plain\fs20 {\v 2U90KW3}, \uldb Invalid whandles\plain\fs20 {\v 0ZFR8E}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0027}
{\up $}{\footnote\pard\plain{\up $} _EdUndo}
{\up #}{\footnote\pard\plain{\up #} 1CN2FM}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _EdUndo}
\b _EdUndo( )
\par \pard \plain\fs20 
\par Undoes the most recent edit in the specified window.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b llresult = _EdUndo(nWhandle)
\par 
\par nWhandle
\par \plain\fs20 
\par The whandle of the edit window.
\par 
\par \b Returns\plain\fs20 
\par 
\par Logical
\par 
\par \b Remarks\plain\fs20 
\par 
\par This function always returns .T.
\par 
\par See Also - \uldb _EdRedo\plain\fs20 {\v 1CJTFM}, \uldb _EdUndoOn\plain\fs20 {\v 88ULOD}, \uldb Invalid whandles\plain\fs20 {\v 0ZFR8E}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0028}
{\up $}{\footnote\pard\plain{\up $} _EdUndoOn}
{\up #}{\footnote\pard\plain{\up #} 88ULOD}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _EdUndoOn}
\b _EdUndoOn( )
\par \pard \plain\fs20 
\par Enables grouping of actions by \uldb \b _EdUndo\plain\b\fs20 {\v 1CN2FM}\plain\fs20  and \uldb _\b EdRedo\plain\b\fs20 {\v 1CJTFM}\plain\fs20 .
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b llresult = _EdUndoOn(nWhandle, lGroup)
\par 
\par nWhandle
\par \plain\fs20 
\par The whandle of the edit window.
\par 
\par \f2\b lGroup\plain\fs20 
\par 
\par If .T. is passed, actions are grouped. .F. turns grouping off.
\par 
\par \b Returns\plain\fs20 
\par 
\par Logical
\par 
\par \b Remarks\plain\fs20 
\par 
\par This function always returns .T. Tests have not shown any difference in the grouping of actions.
\par 
\par \b See Also\plain\fs20  - \uldb _EdRedo\plain\fs20 {\v 1CJTFM}, \uldb _EdUndo\plain\fs20 {\v 1CN2FM}, \uldb Invalid whandles\plain\fs20 {\v 0ZFR8E}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0029}
{\up $}{\footnote\pard\plain{\up $} _FindWindo}
{\up #}{\footnote\pard\plain{\up #} 7G7YBX}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _FindWindo}
\b _FindWindo( )
\par \pard \plain\fs20 
\par Determines the whandle and area of the window based on specified column/row information.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b lnobject = _FindWindo(@nWhandle, nColumn, nRow)
\par 
\par nWhandle
\par \plain\fs20 
\par The variable to receive the whandle value. Must be passed by reference.
\par 
\par \f2\b nColumn\plain\fs20 
\par 
\par The column position within the FoxPro window.
\par 
\par \f2\b nRow\plain\fs20 
\par 
\par The row position in the FoxPro window.
\par 
\par \b Returns\plain\fs20 
\par 
\par Numeric
\par 
\par \b Remarks\plain\fs20 
\par 
\par The value returned should correspond to one of the following declares:
\par \pard\tx355 
\par \f2\b #define inBorder\tab \tab  0\tab * In the window border region
\par #define inHelp\tab \tab  1\tab * In the Help region
\par #define inContent\tab \tab  2\tab * In the content/text region
\par #define inDrag\tab \tab  3\tab * In the Drag/Title bar region
\par #define inGrow\tab \tab  4\tab * In the grow/resize region
\par #define inGoAway\tab \tab  5\tab * In the goAway/close region
\par #define inZoom\tab \tab  6\tab * In the zoom region
\par #define inVUpArrow\tab  7\tab * In the vertical up arrow region
\par #define inVDownArrow\tab  8\tab * In the vertical down arrow region
\par \pard\tx355 #define inVPageUp\tab \tab  9\tab * In the vertical page up region
\par #define inVPageDown\tab 10\tab * In the vertical page down region
\par #define inVThumb\tab \tab 11\tab * In the vertical thumb region
\par #define inHUpArrow\tab 12\tab * In the horizontal up arrow region
\par #define inHDownArrow\tab 13\tab * In the horizontal down arrow region
\par #define inHPageUp\tab \tab 14\tab * In the horizontal page up region
\par #define inHPageDown\tab 15\tab * In the horizontal page down region
\par #define inHThumb\tab \tab 16\tab * In the horizontal thumb region
\par \pard\tx355 #define inMenuBar\tab \tab 17\tab * In the menu bar
\par \plain\fs20 
\par See Also - \uldb _FindWindp\plain\fs20 {\v 7G7YBY}, \uldb Invalid whandles\plain\fs20 {\v 0ZFR8E}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:002a}
{\up $}{\footnote\pard\plain{\up $} _FindWindp}
{\up #}{\footnote\pard\plain{\up #} 7G7YBY}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _FindWindp}
\b _FindWindp( )
\par \pard \plain\fs20 
\par Determines the whandle and area of the window based on specified horizontal and vertical pixel coordinates.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b lnobject = _FindWindp(@nWhandle, nHpos, nVpos)
\par 
\par nWhandle
\par \plain\fs20 
\par The variable to receive the whandle value. Must be passed by reference.
\par 
\par \f2\b nHpos\plain\fs20 
\par 
\par The horizontal position in pixels within the FoxPro window.
\par 
\par \f2\b nVpos\plain\fs20 
\par 
\par The vertical position in pixels in the FoxPro window.
\par 
\par \b Returns\plain\fs20 
\par 
\par Numeric
\par 
\par \b Remarks
\par 
\par \plain\fs20 See the table in \uldb \b _FindWindo\plain\b\fs20 {\v 7G7YBX}\plain\fs20  for a listing of the return values.
\par \pard 
\par \b See Also\plain\fs20  - \uldb _FindWindo\plain\fs20 {\v 7G7YBX}, \uldb Invalid whandles\plain\fs20 {\v 0ZFR8E}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:002b}
{\up $}{\footnote\pard\plain{\up $} _GetWRect}
{\up #}{\footnote\pard\plain{\up #} 8REQUZ}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _GetWRect;Window coordinates}
\b _GetWRect( )
\par \pard \plain\fs20 
\par Returns the absolute coordinates of the window on the desktop.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b llresult = _GetWRect(nHwnd, @nTop, @nLeft, @nBottom, @nRight)
\par 
\par nHwnd
\par \plain\i\fs20 
\par \plain\fs20 The window handle.\i 
\par \plain\fs20 
\par \f2\b nTop\plain\fs20 
\par 
\par The top border of the window.
\par 
\par \f2\b nLeft\plain\fs20 
\par 
\par The left border of the window.
\par 
\par \f2\b nBottom\plain\i\fs20 
\par \plain\fs20 
\par The bottom border of the window.
\par 
\par \f2\b nRight\plain\fs20 
\par 
\par The right border of the window.
\par 
\par \b Returns\plain\fs20 
\par 
\par Logical
\par 
\par \b Remarks\plain\fs20 
\par 
\par Values returned are in pixels. The meaning of the values returned by this function have been determined as a result of calculations including of the title bar and menu for the top portion. This function is not described in any Microsoft documentation. Note that the first value passed in the window handle and not FoxPro\f251 \'92\f11 s whandle. Other values must be passed by reference. Always returns .T.
\par \pard 
\par \b See Also\plain\fs20  - \uldb _WHTohWnd\plain\fs20 {\v 20RGYZ_}, \uldb Invalid whandles\plain\fs20 {\v 0ZFR8E}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:002c}
{\up $}{\footnote\pard\plain{\up $} _WAttr}
{\up #}{\footnote\pard\plain{\up #} BR98WF}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _WAttr;color;color attributes;colors}
\b _WAttr( )
\par \pard \plain\fs20 
\par Returns the attribute byte for the color index in the scheme for the window.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b lnattr = _WAttr(nWhandle, nIndex)
\par 
\par nWhandle
\par \plain\fs20 
\par The window\f251 \'92\f11 s whandle.
\par 
\par \f2\b nIndex
\par \plain\fs20 
\par The index, which ranges from -1 to 10. FoxPro supports 25 separate color schemes.
\par 
\par \b Returns\plain\fs20 
\par 
\par Numeric
\par 
\par \b See Also\plain\fs20  - \uldb _WSetAttr\plain\fs20 {\v 21CX3BM}, \uldb Invalid whandles\plain\fs20 {\v 0ZFR8E}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:002d}
{\up $}{\footnote\pard\plain{\up $} _WBottom}
{\up #}{\footnote\pard\plain{\up #} 3QIR685}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _WBottom;rows}
\b _WBottom( )
\par \pard \plain\fs20 
\par Returns the bottom row number of the specified window.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b lnrow = _WBottom(nWhandle)
\par 
\par nWhandle
\par \plain\fs20 
\par The window\f251 \'92\f11 s whandle.
\par 
\par \b Returns\plain\fs20 
\par 
\par Numeric
\par 
\par \b See Also\plain\fs20  - \uldb _WBottomP\plain\fs20 {\v 99EO9S}, \uldb Invalid whandles\plain\fs20 {\v 0ZFR8E}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:002e}
{\up $}{\footnote\pard\plain{\up $} _WBottomP}
{\up #}{\footnote\pard\plain{\up #} 99EO9S}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _WBottomP;pixels}
\b _WBottomP
\par \pard \plain\fs20 
\par Returns the bottom pixel location of the specified window.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b lnpixel = _WBottomP(nWhandle)
\par 
\par nWhandle
\par \plain\fs20 
\par The window\f251 \'92\f11 s whandle.
\par 
\par \b Returns\plain\fs20 
\par 
\par Numeric
\par 
\par \b See Also\plain\fs20  - \uldb _WBottom\plain\fs20 {\v 3QIR685}, \uldb Invalid whandles\plain\fs20 {\v 0ZFR8E}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:002f}
{\up $}{\footnote\pard\plain{\up $} _WClear}
{\up #}{\footnote\pard\plain{\up #} CBDTCP}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _WClear;clear;display}
\b _WClear( )
\par \pard \plain\fs20 
\par Clears the visible portion of the specified window, without changing the current cursor position.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b llresult = _WClear(nWhandle)
\par 
\par nWhandle
\par \plain\fs20 
\par The window\f251 \'92\f11 s whandle.
\par 
\par \b Returns\plain\fs20 
\par 
\par Logical
\par 
\par \b Remarks\plain\fs20 
\par 
\par Clearing the window does not alter the contents of the file. Only the display is changed. This function also clears areas of forms without changing the background color. Cannot be used to clear an area of the currently active form unless issued from another form or window.
\par \pard 
\par \b See Also\plain\fs20  - \uldb Invalid whandles\plain\fs20 {\v 0ZFR8E}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0030}
{\up $}{\footnote\pard\plain{\up $} _WClearRec}
{\up #}{\footnote\pard\plain{\up #} 1.Y.3FA}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _WClearRec;clear;display'}
\b _WClearRec( )
\par \pard \plain\fs20 
\par Clears display in the specified rectangular area in the specified window based on row and column coordinates.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b llresult = _WClearRec(nWhandle, nTop, nLeft, nBottom, nRight)
\par 
\par nWhandle
\par \plain\fs20 
\par The whandle to of the window to clear.
\par 
\par \f2\b nTop\plain\fs20 
\par 
\par The top row.
\par 
\par \f2\b nLeft\plain\fs20 
\par 
\par The left column
\par 
\par \f2\b nBottom\plain\fs20 
\par 
\par The bottom row.
\par 
\par \f2\b nRight\plain\fs20 
\par 
\par The right column.
\par 
\par \b Returns\plain\fs20 
\par 
\par Logical
\par 
\par \b Remarks\plain\fs20 
\par 
\par This function uses row/column coordinates to specify the rectangular area to clear. Cannot be used to clear an area of the currently active form unless issued from another form or window.
\par \pard \b 
\par See Also\plain\fs20  - \uldb _WClearRep\plain\fs20 {\v 1.Y.3FN}, \uldb Invalid whandles\plain\fs20 {\v 0ZFR8E}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0031}
{\up $}{\footnote\pard\plain{\up $} _WClearRep}
{\up #}{\footnote\pard\plain{\up #} 1.Y.3FN}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _WClearRep;clear;display}
\b _WClearRep( )
\par \pard \plain\fs20 
\par Clears display in the specified rectangular area in the specified window based on pixel coordinates. 
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b llresult = _WClearRep(nWhandle, nTop, nLeft, nBottom, nRight)
\par 
\par nWhandle
\par \plain\fs20 
\par The whandle to of the window to clear.
\par 
\par \f2\b nTop\plain\fs20 
\par 
\par The top most pixel.
\par 
\par \f2\b nLeft\plain\fs20 
\par 
\par The left most pixel.
\par 
\par \f2\b nBottom\plain\fs20 
\par 
\par The bottom most pixel.
\par 
\par \f2\b nRight\plain\fs20 
\par 
\par The right most pixel.
\par 
\par \b Returns\plain\fs20 
\par 
\par Logical
\par 
\par \b Remarks\plain\fs20 
\par 
\par This function uses pixel coordinates to specify the rectangular area to clear. Cannot be used to clear an area of the currently active form unless issued from another form or window.
\par \pard 
\par \b See Also\plain\fs20  - \uldb _WClearRec\plain\fs20 {\v 1.Y.3FA}, \uldb Invalid whandles\plain\fs20 {\v 0ZFR8E}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0032}
{\up $}{\footnote\pard\plain{\up $} _WClose}
{\up #}{\footnote\pard\plain{\up #} CBE3UC}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _WClose;close}
\b _WClose( )
\par \pard \plain\fs20 
\par Closes the window and releases the memory associated with it.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b llresult = _WClose(nWhandle)
\par 
\par nWhandle
\par \plain\fs20 
\par The window\f251 \'92\f11 s whandle.
\par 
\par \b Returns\plain\fs20 
\par 
\par Logical
\par 
\par \b See Also\plain\fs20  - \uldb Invalid whandles\plain\fs20 {\v 0ZFR8E}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0033}
{\up $}{\footnote\pard\plain{\up $} _WFindTitl}
{\up #}{\footnote\pard\plain{\up #} CM7U01}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _WFindTitl;whandle}
\b _WFindTitl( )
\par \pard \plain\fs20 
\par Returns the whandle based on the window\f251 \'92\f11 s title text.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b lnwhandle = _WFindTitl(cTitle)
\par 
\par cTitle
\par \plain\fs20 
\par The title text. Any valid string may used: _SCREEN.Caption, ThisForm.Caption, lctitletext.
\par 
\par \b Returns\plain\fs20 
\par 
\par Numeric
\par 
\par \b Remarks\plain\fs20 
\par 
\par The whandle is used by most of the edit (beginning _E) and window functions (beginning _W) in FOXTOOLS.
\par 
\par \b See Also \plain\fs20 -\b  \uldb \plain\uldb\fs20 _WGetPort\plain\fs20 {\v 9NCRG_}, \uldb _WHToHWnd\plain\fs20 {\v 20RGYZ_}, \uldb _WMainWind\plain\fs20 {\v EW3BSD}, \uldb _WOnTop\plain\fs20 {\v CNG8QN}, \uldb _WSetPort\plain\fs20 {\v M1NZ.Z}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0034}
{\up $}{\footnote\pard\plain{\up $} _WFooter}
{\up #}{\footnote\pard\plain{\up #} 16OH7QP}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _WFooter}
\b _WFooter( )
\par \pard \plain\fs20 
\par The purpose of this function is unknown. It is assumed that its purpose is to set a footer title.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b = _WFooter(nWhandle, cExpr)
\par 
\par nWhandle
\par \plain\fs20 
\par The window\f251 \'92\f11 s whandle.
\par 
\par \f2\b cExpr\plain\fs20 
\par 
\par Any character expression.
\par 
\par \b Remarks\plain\fs20 
\par 
\par Passing the above parameters to this function produces a \'93feature not available\'94 error message.
\par 
\par \b See Also\plain\fs20  - \uldb Invalid whandles\plain\fs20 {\v 0ZFR8E}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0035}
{\up $}{\footnote\pard\plain{\up $} _WGetCurP}
{\up #}{\footnote\pard\plain{\up #} 9N6XG9}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _WGetCurP}
\b _WGetCurP( )
\par \pard \plain\fs20 
\par The description of this function in the FoxPro help states that it is to supposed to return the current cursor position in pixels. Tests, however, indicate that it always returns 3.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b lnresult = _WGetCurP(nWhandle, nExpr1, nExpr2)
\par 
\par nWhandle
\par \plain\fs20 
\par This window\f251 \'92\f11 s whandle.
\par 
\par \f2\b nExpr1, nExpr2\plain\fs20 
\par 
\par Numeric expressions.
\par 
\par \b Returns\plain\fs20 
\par 
\par Numeric
\par 
\par \b Remarks\plain\fs20 
\par 
\par It is assumed that the whandle is the required value. This is supported by the FoxPro Help file. Further, attempting to pass the window handle (hWnd) generates a General Protection Fault. Passing the values nExpr1 and nExpr2 by reference produces a data type mismatch error.
\par \pard 
\par \b See Also\plain\fs20  - \uldb _WGetCurso\plain\fs20 {\v 861MMF}, \uldb Invalid whandles\plain\fs20 {\v 0ZFR8E}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0036}
{\up $}{\footnote\pard\plain{\up $} _WGetCurso}
{\up #}{\footnote\pard\plain{\up #} 861MMF}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _GetGetCurso}
\b _WGetCurso( )
\par \pard \plain\fs20 
\par The description of this function in the FoxPro help states that it is to supposed to return the current cursor position in rows and columns. Tests, however, indicate that it always returns 3.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b lnresult = _WGetCurso(nWhandle, nExpr1, nExpr2)
\par 
\par nWhandle
\par \plain\fs20 
\par This window\f251 \'92\f11 s whandle.
\par 
\par \f2\b nExpr1, nExpr2
\par \plain\fs20 
\par Numeric expressions.
\par 
\par \b Returns\plain\fs20 
\par 
\par Numeric
\par 
\par \b Remarks\plain\fs20 
\par 
\par It is assumed that the whandle is the required value. This is supported by the FoxPro Help file. Further, attempting to pass the window handle (hWnd) generates a General Protection Fault. Passing the values nExpr1 and nExpr2 by reference produces a data type mismatch error.
\par \pard 
\par \b See Also\plain\fs20  - \uldb _WGetCurP\plain\fs20 {\v 9N6XG9}, \uldb Invalid whandles\plain\fs20 {\v 0ZFR8E}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0037}
{\up $}{\footnote\pard\plain{\up $} _WGetPort}
{\up #}{\footnote\pard\plain{\up #} 9NCRG_}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _WGetPort;whandle}
\b _WGetPort( )
\par \pard \plain\fs20 
\par Returns the whandle of the current output window.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b lnwhandle = _WGetPort()
\par \plain\i\fs20 
\par \plain\b\fs20 Returns\plain\fs20 
\par 
\par Numeric
\par 
\par \b Remarks
\par \plain\fs20 
\par The current output window is the window that will display information printed with the ? command.
\par 
\par \b See Also \plain\fs20 -\b  \uldb \plain\uldb\fs20 _WFindTitl\plain\fs20 {\v CM7U01}, \uldb _WHToHWnd\plain\fs20 {\v 20RGYZ_}, \uldb _WMainWind\plain\fs20 {\v EW3BSD}, \uldb _WOnTop\plain\fs20 {\v CNG8QN}, \uldb _WSetPort\plain\fs20 {\v M1NZ.Z}, \uldb _WSetPort\plain\fs20 {\v M1NZ.Z}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0038}
{\up $}{\footnote\pard\plain{\up $} _WHeight}
{\up #}{\footnote\pard\plain{\up #} F.5V_B}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _WHeight;height}
\b _WHeight( )
\par \pard \plain\fs20 
\par Returns the height in rows of the specified window.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b lnrows = _WHeight(nWhandle)
\par 
\par nWhandle
\par \plain\fs20 
\par The whandle of the window.
\par 
\par \b Returns\plain\fs20 
\par 
\par Numeric
\par 
\par \b See Also\plain\fs20  - \uldb _WHeightP\plain\fs20 {\v G9YL1T}, \uldb Invalid whandles\plain\fs20 {\v 0ZFR8E}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0039}
{\up $}{\footnote\pard\plain{\up $} _WHeightP}
{\up #}{\footnote\pard\plain{\up #} G9YL1T}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _WHeightP;height}
\b _WHeightP( )
\par \pard \plain\fs20 
\par Returns the height in pixels of the specified window.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b lnpixels = _WHeightP(nWhandle)
\par 
\par nWhandle
\par 
\par \plain\fs20 The whandle of the window.
\par 
\par \b Returns\plain\fs20 
\par 
\par Numeric
\par 
\par \b See Also\plain\fs20  - \uldb _WHeight\plain\fs20 {\v F.5V_B}, \uldb Invalid whandles\plain\fs20 {\v 0ZFR8E}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:003a}
{\up $}{\footnote\pard\plain{\up $} _WHide}
{\up #}{\footnote\pard\plain{\up #} 1R9WWJY}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _WHide}
\b _WHide( )
\par \pard \plain\fs20 
\par Hides the specified window, but keeps track of its contents so that it can be displayed later.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b llresult = _WHide(nWhandle)
\par 
\par nWhandle
\par \plain\fs20 
\par The whandle of the window to hide.
\par 
\par \b Returns\plain\fs20 
\par 
\par Logical
\par 
\par \b Remarks\plain\fs20 
\par 
\par Returns .T. if the window is hidden. If the window indicated by nWhandle does not exist, VFP may generate a General Protection Fault.
\par 
\par \b See Also\plain\fs20  - \uldb _WShow\plain\fs20 {\v BRJWRK}, \uldb Invalid whandles\plain\fs20 {\v 0ZFR8E}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:003b}
{\up $}{\footnote\pard\plain{\up $} _WHToHWnd}
{\up #}{\footnote\pard\plain{\up #} 20RGYZ_}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _WHToHWnd;whandle;window handle}
\b _WHTohWnd( )
\par \pard \plain\fs20 
\par Returns the window handle from the whandle value.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b lnhWnd = _WHToHWnd(nWhandle)
\par 
\par nWhandle
\par \plain\fs20 
\par The window\f251 \'92\f11 s whandle.
\par 
\par \b Returns\plain\fs20 
\par 
\par Numeric
\par 
\par \b See Also\plain\fs20  - \uldb _WFindTitl\plain\fs20 {\v CM7U01}, \uldb _WGetPort\plain\fs20 {\v 9NCRG_}, \uldb _WMainWind\plain\fs20 {\v EW3BSD}, \uldb _WOntop\plain\fs20 {\v CNG8QN}, \uldb _WSetPort\plain\fs20 {\v M1NZ.Z}, \uldb Invalid whandles\plain\fs20 {\v 0ZFR8E}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:003c}
{\up $}{\footnote\pard\plain{\up $} _WLeft}
{\up #}{\footnote\pard\plain{\up #} BRCTIH}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _WLeft;column position}
\b _WLeft( )
\par \pard \plain\fs20 
\par Returns the left most column of the specified window.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b lncolumn = _WLeft(nWhandle)
\par 
\par nWhandle
\par \plain\fs20 
\par The window\f251 \'92\f11 s whandle.
\par 
\par \b Returns\plain\fs20 
\par 
\par Numeric
\par 
\par \b See Also\plain\fs20  - \uldb _WLeftP\plain\fs20 {\v CK_UVN}, \uldb Invalid whandles\plain\fs20 {\v 0ZFR8E}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:003d}
{\up $}{\footnote\pard\plain{\up $} _WLeftP}
\pard\keepn\sb235\sa55 {\up #}{\footnote\pard\plain{\up #} CK_UVN}
{\up K}{\footnote\pard\plain{\up K} _WLeftP;pixel position}
\b _WLeftP( )
\par \pard \plain\fs20 
\par Returns the left most pixel position of the specified window.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b lnpixel = _WLeft(nWhandle)
\par 
\par nWhandle
\par \plain\fs20 
\par The window\f251 \'92\f11 s whandle.
\par 
\par \b Returns\plain\fs20 
\par 
\par Numeric
\par 
\par \b See Also\plain\fs20  - \uldb _WLeft\plain\fs20 {\v BRCTIH}, \uldb Invalid whandles\plain\fs20 {\v 0ZFR8E}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:003e}
{\up $}{\footnote\pard\plain{\up $} _WMainWind}
{\up #}{\footnote\pard\plain{\up #} EW3BSD}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _WmainWind;whandle}
\b _WMainWind( )
\par \pard \plain\fs20 
\par Returns the whandle of the main FoxPro window.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b lnwhandle = _WMainWind()
\par \plain\fs20 
\par \b Returns\plain\fs20 
\par 
\par Numeric
\par 
\par \b See Also \plain\fs20 -\uldb _WFindTitl\plain\fs20 {\v CM7U01},\b  \uldb \plain\uldb\fs20 _WGetPort\plain\fs20 {\v 9NCRG_}, \uldb _WHToHWnd\plain\fs20 {\v 20RGYZ_}, \uldb _WOntop\plain\fs20 {\v CNG8QN}, \uldb _WSetPort\plain\fs20 {\v M1NZ.Z}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:003f}
{\up $}{\footnote\pard\plain{\up $} _WMove}
{\up #}{\footnote\pard\plain{\up #} BRE3Y9}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _WMove;move}
\b _WMove( )
\par \pard \plain\fs20 
\par Moves the specified window to new column/row coordinates.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b llresult = _WMove(nWhandle, nColumn, nRow)
\par 
\par nWhandle
\par \plain\fs20 
\par The window\f251 \'92\f11 s whandle.
\par 
\par \f2\b nCol\plain\fs20 
\par 
\par The new column position. 
\par 
\par \f2\b nRow
\par \plain\fs20 
\par The new row position.
\par 
\par \b Returns\plain\fs20 
\par 
\par Logical
\par 
\par \b Remarks\plain\fs20 
\par 
\par The position indicated is relative to the FoxPro desktop. It may, however, be off the screen.
\par 
\par \b See Also\plain\fs20  - \uldb _WMoveP\plain\fs20 {\v CLH0GN}, \uldb Invalid whandles\plain\fs20 {\v 0ZFR8E}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0040}
{\up $}{\footnote\pard\plain{\up $} _WMoveP}
{\up #}{\footnote\pard\plain{\up #} CLH0GN}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _WmoveP;move}
\b _WMoveP( )
\par \pard \plain\fs20 
\par Moves the specified window to a new position specified by pixel coordinates.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b llresult = _WMoveP(nWhandle, nHorzPos, nVertPos)
\par 
\par nWhandle
\par \plain\fs20 
\par The window\f251 \'92\f11 s whandle.
\par 
\par \f2\b nHorzPos\plain\fs20 
\par 
\par The horizontal pixel coordinate.
\par 
\par \f2\b nVertPos\plain\fs20 
\par 
\par The vertical pixel coordinate.
\par 
\par \b Returns\plain\fs20 
\par 
\par Logical
\par 
\par \b Remarks\plain\fs20 
\par 
\par The position indicated is relative to the FoxPro desktop. It may, however, be off the screen.
\par 
\par \b See Also\plain\fs20  - \uldb _WMove\plain\fs20 {\v BRE3Y9}, \uldb Invalid whandles\plain\fs20 {\v 0ZFR8E}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0041}
{\up $}{\footnote\pard\plain{\up $} _WOnTop}
{\up #}{\footnote\pard\plain{\up #} CNG8QN}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _WOnTop;whandle}
\b _WOnTop( )
\par \pard \plain\fs20 
\par Returns the whandle handle of the foremost window.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b lnwhandle = _WOnTop()
\par \plain\fs20 
\par \b Returns\plain\fs20 
\par 
\par Numeric
\par 
\par \b See Also \plain\fs20 -\b  \uldb \plain\uldb\fs20 _WFindTitl\plain\fs20 {\v CM7U01}, \uldb _WGetPort\plain\fs20 {\v 9NCRG_}, \uldb _WHToHWnd\plain\fs20 {\v 20RGYZ_}, \uldb _WMainWind\plain\fs20 {\v EW3BSD}, \uldb _WSetPort\plain\fs20 {\v M1NZ.Z}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0042}
{\up $}{\footnote\pard\plain{\up $} _WOpen}
{\up #}{\footnote\pard\plain{\up #} BRG4HB}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _WOpen}
\b _WOpen( )
\par \pard \plain\fs20 
\par Creates a window of a specified type at the specified location. Values passed that indicate location and size are in rows and columns. Value returned is the whandle of the opened window.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b lnwhandle = _WOpen(nTop, nLeft, nBottom, nRight, nFlag,;
\par   nColorScheme, cColorScheme, cBorder)
\par 
\par nTop
\par \plain\fs20 
\par The top row.
\par 
\par \f2\b nLeft\plain\fs20 
\par 
\par The left column.
\par 
\par \f2\b nBottom\plain\fs20 
\par 
\par The bottom row.
\par 
\par \f2\b nRight\plain\fs20 
\par 
\par The right column.
\par 
\par \f2\b nFlag\plain\fs20 
\par 
\par A combination of one or more of the following values:
\par \pard\tx355 
\par \f2\b #DEFINE WCURSOR\tab \tab    2\tab && Enable the cursor
\par #DEFINE ZOOM\tab \tab    4\tab && Permit the window to be zoomed
\par #DEFINE ADJ\tab \tab \tab    8\tab && Allow Window Size to be Adjusted
\par #DEFINE CLOSE\tab \tab   16\tab && Permit Closing of System Window
\par #DEFINE MOVE\tab \tab   32\tab && Allow the window to be moved
\par #DEFINE HSCROLLBAR\tab   64\tab && Show Horizontal Scrollbars
\par #DEFINE VSCROLLBAR\tab  128\tab && Show Vertical Scrollbars
\par #DEFINE AUTOSCROLL\tab  256\tab && Window should Auto scroll
\par #DEFINE WEVENT\tab \tab 1024\tab && Participates in activate/deact events
\par \pard\tx355 #DEFINE SHADOW\tab \tab 2048\tab && Window will produce a shadow
\par #DEFINE WMODAL\tab \tab 4096\tab && Window is a modal window
\par #DEFINE WMINIMIZE\tab \tab 8192\tab && Window can be minimized
\par \plain\fs20 
\par \f2\b nColorScheme\plain\fs20 
\par 
\par One of the following may be used. If -1 is passed, the color scheme specified the \f2\b cColorSchem\plain\i\fs20 e\plain\fs20  parameter is used.
\par 
\par \f2\b #DEFINE USER_SCHEME \tab \tab \tab  0
\par #DEFINE USERMENU_SCHEME\tab \tab \tab  1
\par #DEFINE MBAR_SCHEME\tab \tab \tab  2
\par #DEFINE POPUP_SCHEME\tab \tab \tab  3
\par #DEFINE DIALOG_SCHEME\tab \tab \tab  4
\par \pard\tx355 #DEFINE MODAL_POPUP_SCHEME\tab \tab  5
\par #DEFINE ALERT_SCHEME\tab \tab \tab  6
\par #DEFINE WINDOW_SCHEME\tab \tab \tab  7
\par #DEFINE NONMODAL_POPUP_SCHEME\tab \tab  8
\par #DEFINE BROWSE_SCHEME\tab \tab \tab  9
\par #DEFINE REPORT_SCHEME\tab \tab \tab 10
\par #DEFINE ALERT_POPUP_SCHEME\tab \tab 11
\par \plain\fs20 
\par \f2\b cColorScheme
\par \plain\fs20 
\par This parameter is ignored unless the \f2\b nColorScheme\plain\fs20  parameter is set to -1. A 12 character string made up of characters with combinations of the following ASCII characters.
\par 
\par \f2\b * Foreground color attributes
\par #DEFINE BLACK_ON \tab \tab 0
\par \pard\tx355 #DEFINE BLUE_ON\tab \tab 1
\par #DEFINE GREEN_ON\tab \tab 2
\par #DEFINE CYAN_ON\tab \tab 3
\par #DEFINE RED_ON\tab \tab 4
\par #DEFINE MAGENTA_ON\tab 5
\par #DEFINE BROWN_ON\tab \tab 6
\par #DEFINE WHITE_ON\tab \tab 7
\par 
\par * Background color attributes.
\par #DEFINE BLACK\tab \tab BITLSHIFT(BLACK_ON, 4) 
\par #DEFINE BLUE\tab \tab BITLSHIFT(BLUE_ON, 4)
\par #DEFINE GREEN\tab \tab BITLSHIFT(GREEN_ON, 4)
\par #DEFINE CYAN\tab \tab BITLSHIFT(CYAN_ON, 4)
\par #DEFINE RED\tab \tab \tab BITLSHIFT(RED_ON, 4)
\par #DEFINE MAGENTA\tab \tab BITLSHIFT(MAGENTA_ON, 4)
\par #DEFINE BROWN\tab \tab BITLSHIFT(BROWN_ON, 4)
\par \pard\tx355 #DEFINE WHITE\tab \tab BITLSHIFT(WHITE_ON, 4)
\par 
\par * Miscellaneous values
\par #DEFINE BRIGHT\tab \tab 8\tab && Intensify foreground color 
\par #DEFINE BLINK\tab \tab 128\tab && Blink
\par 
\par \plain\fs20 For example, to create a black on white element, set the value of the character to \f2\b CHR(BLACK_ON + WHITE)\plain\fs20 .
\par 
\par \f2\b Cborder
\par \plain\fs20 
\par A string defining the border style. This may be defined as one of the following:
\par 
\par \f2\b #DEFINE WO_DOUBLEBOX\tab "\'5cx0cd\'5cx0cd\'5cx0ba\'5cx0ba\'5cx0c9\'5cx0bb\'5cx0c8\'5cx0bc\'5cx0cd\'5cx0cd\'5cx0ba\'5cx0ba\'5cx0c9\'5cx0bb\'5cx0c8\'5cx0bc"
\par \pard\tx355 #DEFINE WO_SINGLEBOX\tab "\'5cx0c4\'5cx0c4\'5cx0b3\'5cx0b3\'5cx0da\'5cx0bf\'5cx0c0\'5cx0d9\'5cx0c4\'5cx0c4\'5cx0b3\'5cx0b3\'5cx0da\'5cx0bf\'5cx0c0\'5cx0d9"
\par #DEFINE WO_PANELBORDER\tab "\'5cx0db\'5cx0db\'5cx0db\'5cx0db\'5cx0db\'5cx0db\'5cx0db\'5cx0db\'5cx0db\'5cx0db\'5cx0db\'5cx0db\'5cx0db\'5cx0db\'5cx0db\'5cx0db"
\par #DEFINE WO_SYSTEMBORDER "\'5cx020\'5cx020\'5cx020\'5cx020\'5cx0fe\'5cx0f0\'5cx020\'5cx0f9\'5cx020\'5cx020\'5cx020\'5cx020\'5cx020\'5cx020\'5cx020\'5cx020"
\par \plain\fs20 
\par \b Returns\plain\fs20 
\par 
\par Numeric
\par 
\par \b Remarks\plain\fs20 
\par 
\par In testing under VFP 5.0, a call to this function always produced a window with a half-height title bar. The system seemed to ignore certain settings for the flags (e.g. horizontal or vertical scroll bars, borders).
\par \pard\tx355 
\par \b See Also\plain\fs20  - \uldb _WOpenP\plain\fs20 {\v CNHTPN}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0043}
{\up $}{\footnote\pard\plain{\up $} _WOpenP}
{\up #}{\footnote\pard\plain{\up #} CNHTPN}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _WOpenP}
\b _WOpenP( )
\par \pard \plain\fs20 
\par Creates a window of a specified type at the specified location. Values passed that indicate location and size are in pixels. Value returned is the whandle of the opened window. See \uldb \b _WOpen\plain\b\fs20 {\v BRG4HB}\plain\fs20  for the declares and values of the \f2\b nFlag, nColorScheme, cColorScheme\plain\fs20 , and \f2\b cBorder\plain\fs20  parameters.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b lnwhandle = _WOpenP(nTop, nLeft, nBottom, nRight, nFlag,;
\par   nColorScheme, cColorScheme, cBorder)
\par \plain\i\fs20 
\par \plain\f2\b\fs20 nTop\plain\i\fs20 
\par \plain\fs20 
\par The top pixel location.
\par \pard 
\par \f2\b nLeft\plain\fs20 
\par 
\par The left pixel location.
\par 
\par \f2\b nBottom\plain\fs20 
\par 
\par The bottom pixel location.
\par 
\par \f2\b nRight\plain\fs20 
\par 
\par The right pixel location.
\par 
\par \f2\b nFlag\plain\fs20 
\par 
\par Defines the window\f251 \'92\f11 s attributes.
\par 
\par \f2\b nColorScheme\plain\fs20 
\par 
\par One of the following may be used. If -1 is passed, the color scheme specified the \i cColorScheme\plain\fs20  parameter is used.
\par 
\par \f2\b cColorScheme\plain\fs20 
\par 
\par This parameter is ignored unless the \i nColorScheme\plain\fs20  parameter is set to -1. A 12 character string.
\par \pard 
\par \f2\b Cborder\plain\fs20 
\par 
\par A string defining the border style. 
\par 
\par \b Returns\plain\fs20 
\par 
\par Numeric
\par 
\par \b Remarks\plain\fs20 
\par 
\par In testing under VFP 5.0, a call to this function always produced a window with a half-height title bar. The system seemed to ignore certain settings for the flags (e.g. horizontal or vertical scroll bars or border).
\par 
\par \b See Also\plain\fs20  - \uldb _WOpen\plain\fs20 {\v BRG4HB}
\par 
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0044}
{\up $}{\footnote\pard\plain{\up $} _WPutChr}
{\up #}{\footnote\pard\plain{\up #} 233XQA5}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _WPutChr;output}
\b _WPutChr( )
\par \pard \plain\fs20 
\par Outputs a character in the specified window at the current position.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b llresult = _WPutChr(nWhandle, cExpr)
\par 
\par nWhandle
\par \plain\fs20 
\par The window\f251 \'92\f11 s whandle.
\par 
\par \f2\b cExpr\plain\fs20 
\par 
\par The character to display.
\par 
\par \b Returns\plain\fs20 
\par 
\par Logical
\par 
\par \b See Also\plain\fs20  - \uldb _WPutStr\plain\fs20 {\v 233Y6M5}, \uldb Invalid whandles\plain\fs20 {\v 0ZFR8E}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0045}
{\up $}{\footnote\pard\plain{\up $} _WPutStr}
{\up #}{\footnote\pard\plain{\up #} 233Y6M5}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _WPutStr;output}
\b _WPutStr( )
\par \pard \plain\fs20 
\par Outputs a string of characters at the current output location in the specified in window.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b llresult = _WPutStr(nWhandle, cExpr)
\par 
\par nWhandle
\par \plain\fs20 
\par The window\f251 \'92\f11 s whandle.
\par 
\par \f2\b cExpr\plain\fs20 
\par 
\par The string to display.
\par 
\par \b Returns\plain\fs20 
\par 
\par Logical
\par 
\par \b See Also\plain\fs20  - \uldb _WPutChr\plain\fs20 {\v 233XQA5}, \uldb Invalid whandles\plain\fs20 {\v 0ZFR8E}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0046}
{\up $}{\footnote\pard\plain{\up $} _WPosCurso}
{\up #}{\footnote\pard\plain{\up #} 33Z_TBN}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _WPosCurso}
\b _WPosCurso( )
\par \pard \plain\fs20 
\par Documentation indicates that this function sets the output position of the specified window to the defined column and row positions..
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b llresult = _WPosCurso(nWhandle, nCol, nRow)
\par 
\par nWhandle
\par \plain\fs20 
\par The window\f251 \'92\f11 s whandle.
\par 
\par \f2\b nCol\plain\fs20 
\par 
\par The output column.
\par 
\par \f2\b nRow\plain\fs20 
\par 
\par The output row.
\par \b 
\par Returns\plain\fs20 
\par 
\par Logical
\par 
\par \b Remarks\plain\fs20 
\par 
\par Tests with forms show that the column position is not affected by the value passed. Output always was at the first column. The initial output position should be set by consecutive calls indicating the same location.
\par \pard 
\par \b See Also\plain\fs20  \uldb _WPosCurP\plain\fs20 {\v 1Z_42H5}, \uldb Invalid whandles\plain\fs20 {\v 0ZFR8E}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0047}
{\up $}{\footnote\pard\plain{\up $} _WPosCurP}
{\up #}{\footnote\pard\plain{\up #} 1Z_42H5}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _WPosCurP}
\b _WPosCurP( )
\par \pard \plain\fs20 
\par Documentation indicates that this function sets the output position of the specified window to the defined pixel coordinates.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b llresult = _WPosCurP(nWhandle, nHorzPos, nVertPos)
\par 
\par nWhandle
\par \plain\fs20 
\par The window\f251 \'92\f11 s whandle.
\par 
\par \f2\b nHorzPos\plain\fs20 
\par 
\par The output horizontal position.
\par 
\par \f2\b nVertPos\plain\fs20 
\par 
\par The output vertical position.
\par \b 
\par Returns\plain\fs20 
\par 
\par Logical
\par \b 
\par Remarks\plain\fs20 
\par 
\par Tests with forms show that the horizontal pixel location is not affected by the value passed. Output always was at horizontal position 0. The initial output position should be set by consecutive calls indicating the same location.
\par \pard 
\par \b See Also\plain\fs20  \uldb _WPosCurso\plain\fs20 {\v 33Z_TBN}, \uldb Invalid whandles\plain\fs20 {\v 0ZFR8E}
\par 
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0048}
{\up $}{\footnote\pard\plain{\up $} _WRight}
{\up #}{\footnote\pard\plain{\up #} CQAVJR}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _WRight;column}
\b _WRight( )
\par \pard \plain\fs20 
\par Returns the rightmost column in the screen of a window.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b lnrightcol = _WRight(nWhandle)
\par 
\par nWhandle
\par \plain\fs20 
\par The window\f251 \'92\f11 s whandle.
\par 
\par \b Returns\plain\fs20 
\par 
\par Numeric
\par 
\par \b See Also\plain\fs20  - \uldb _WRightP\plain\fs20 {\v 36RX1Y}, \uldb Invalid whandles\plain\fs20 {\v 0ZFR8E}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0049}
{\up $}{\footnote\pard\plain{\up $} WRightP}
{\up #}{\footnote\pard\plain{\up #} 36RX1Y}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _WRightP;pixel}
\b _WRightP( )
\par \pard \plain\fs20 
\par Returns the rightmost pixel in the screen of a window.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b lnrightpix = _WRightP(nWhandle)
\par 
\par nWhandle
\par \plain\fs20 
\par The window\f251 \'92\f11 s whandle.
\par 
\par \b Returns\plain\fs20 
\par 
\par Numeric
\par 
\par \b See Also\plain\fs20  - \uldb _WRight\plain\fs20 {\v CQAVJR}, \uldb Invalid whandles\plain\fs20 {\v 0ZFR8E}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:004a}
{\up $}{\footnote\pard\plain{\up $} _WScroll}
{\up #}{\footnote\pard\plain{\up #} 4133TU}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _WScroll;scroll}
\b _WScroll( )
\par \pard \plain\fs20 
\par Scrolls the specified rectangular area of a window in rows and/or columns.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b llresult = _WScroll(nWhandle, nTop, nLeft, nBottom, nRight, nRows, nCols)
\par 
\par nWhandle
\par \plain\fs20 
\par The window\f251 \'92\f11 s whandle.
\par 
\par \f2\b nTop\plain\fs20 
\par 
\par The top row defining the rectangular area to scroll.
\par 
\par \f2\b nLeft\plain\fs20 
\par 
\par The left column of the area to scroll.
\par 
\par \f2\b nBottom\plain\fs20 
\par 
\par The bottom row of the scroll area.
\par 
\par \f2\b nRight\plain\fs20 
\par 
\par The right column of the scroll area.
\par 
\par \f2\b nRows\plain\fs20 
\par \pard 
\par The number of rows to scroll. Positive numbers scroll the area down, negative up.
\par 
\par \f2\b nCols\plain\fs20 
\par 
\par The number of columns to scroll. Positive numbers scroll the area to the right, negative to the left.
\par 
\par \b Returns\plain\fs20 
\par 
\par Logical
\par 
\par \b Remarks\plain\fs20 
\par 
\par This function works only with program/text edit windows.
\par 
\par \b See Also\plain\fs20  - \uldb _WScrollP\plain\fs20 {\v JZMW6V}, \uldb Invalid whandles\plain\fs20 {\v 0ZFR8E}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:004b}
{\up $}{\footnote\pard\plain{\up $} _WScrollP}
{\up #}{\footnote\pard\plain{\up #} JZMW6V}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _WScrollP;scroll}
\b _WScrollP( )
\par \pard \plain\fs20 
\par Scrolls the specified rectangular area of a window in pixels.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b llresult = _WScrollP(nWhandle, nTop, nLeft, nBottom, nRight, nVertpix, nCols)
\par \plain\fs20 
\par \f2\b nWhandle\plain\fs20 
\par 
\par The window\f251 \'92\f11 s whandle.
\par 
\par \f2\b nTop\plain\fs20 
\par 
\par The top pixel value defining the rectangular area to scroll.
\par 
\par \f2\b nLeft\plain\fs20 
\par 
\par The left pixel value of the area to scroll.
\par 
\par \f2\b nBottom\plain\fs20 
\par 
\par The bottom pixel value of the scroll area.
\par 
\par \f2\b nRight\plain\fs20 
\par 
\par The right pixel value of the scroll area.
\par \pard 
\par \f2\b nVertpix\plain\fs20 
\par 
\par The number of vertical pixels to scroll. Positive numbers scroll the area down, negative up.
\par 
\par \f2\b nHorzpix\plain\fs20 
\par 
\par The number of horizontal pixels to scroll. Positive numbers scroll the area to the right, negative to the left.
\par 
\par \b Returns\plain\fs20 
\par 
\par Logical
\par 
\par \b Remarks\plain\fs20 
\par 
\par This function works only with program/text edit windows.
\par 
\par \b See Also\plain\fs20  - \uldb _WScroll\plain\fs20 {\v 4133TU}, \uldb Invalid whandles\plain\fs20 {\v 0ZFR8E}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:004c}
{\up $}{\footnote\pard\plain{\up $} _WSelect}
{\up #}{\footnote\pard\plain{\up #} 42WTL2}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _WSelect}
\b _WSelect( )
\par \pard \plain\fs20 
\par Brings the specified window to the foreground (places it first in the Z order).
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b llresult = _WSelect(nWhandle)
\par 
\par nWhandle
\par \plain\fs20 
\par The window\f251 \'92\f11 s whandle.
\par 
\par \b Returns\plain\fs20 
\par 
\par Logical
\par 
\par See Also - \uldb _WSendBehi\plain\fs20 {\v 1NRFAYN}, \uldb Invalid whandles\plain\fs20 {\v 0ZFR8E}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:004d}
{\up $}{\footnote\pard\plain{\up $} _WSendBehi}
{\up #}{\footnote\pard\plain{\up #} 1NRFAYN}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _WSendBehi}
\b _WSendBehi( )
\par \pard \plain\fs20 
\par Places the specified window and the end of the window queue (places it last in the Z order).
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b llresult =_WSendBehi(nWhandle)
\par 
\par nWhandle
\par \plain\fs20 
\par The window\f251 \'92\f11 s whandle
\par 
\par \b Returns\plain\fs20 
\par 
\par Logical
\par 
\par See Also - \uldb _WSelect\plain\fs20 {\v 42WTL2}, \uldb Invalid whandles\plain\fs20 {\v 0ZFR8E}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:004e}
{\up $}{\footnote\pard\plain{\up $} _WSetAttr}
{\up #}{\footnote\pard\plain{\up #} 21CX3BM}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _WSetAttr;attributes;color}
\b _WSetAttr( )
\par \pard \plain\fs20 
\par Sets the attribute of the specified window\f251 \'92\f11 s color scheme.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b llresult = _WSetAttr(nWhandle, nScheme, nAttr)
\par 
\par nWhandle
\par \plain\fs20 
\par The window\f251 \'92\f11 s whandle.
\par 
\par \f2\b nScheme\plain\fs20 
\par 
\par The color scheme.
\par 
\par \f2\b nAttr\plain\fs20 
\par 
\par The color attribute.
\par 
\par \b Returns\plain\fs20 
\par 
\par Logical
\par 
\par \b See Also\plain\fs20  - \uldb _WAttr\plain\fs20 {\v BR98WF}, \uldb Invalid whandles\plain\fs20 {\v 0ZFR8E}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:004f}
{\up $}{\footnote\pard\plain{\up $} _WSetPort}
{\up #}{\footnote\pard\plain{\up #} M1NZ.Z}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _WSetPort;whandle}
\b _WSetPort( )
\par \pard \plain\fs20 
\par Sets the current output window.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b lnprev = _WSetPort(nWhandle)
\par 
\par nWhandle
\par \plain\fs20 
\par The window\f251 \'92\f11 s whandle.
\par 
\par \b Returns\plain\fs20 
\par 
\par Numeric
\par 
\par \b Remarks\plain\fs20 
\par 
\par The value returned is the previous output window\f251 \'92\f11 s whandle.
\par 
\par \b See Also \plain\fs20 -\b  \uldb \plain\uldb\fs20 _WFindTitl\plain\fs20 {\v CM7U01}, \uldb _WGetPort\plain\fs20 {\v 9NCRG_}, \uldb _WHToHWnd\plain\fs20 {\v 20RGYZ_}, \uldb _WMainWind\plain\fs20 {\v EW3BSD}, \uldb _WOnTop\plain\fs20 {\v CNG8QN}, \uldb Invalid whandles\plain\fs20 {\v 0ZFR8E}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0050}
{\up $}{\footnote\pard\plain{\up $} _WSetTitle}
{\up #}{\footnote\pard\plain{\up #} EP5QYU}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _WSetTitle}
\b _WSetTitle( )
\par \pard \plain\fs20 
\par Sets the title (caption) of the specified window.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b llresult = _WSetTitle(nWhandle, cCaption)
\par 
\par nWhandle
\par \plain\fs20 
\par The window\f251 \'92\f11 s whandle.
\par 
\par \f2\b cCaption\plain\fs20 
\par 
\par The new title bar caption.
\par 
\par \b Returns\plain\fs20 
\par 
\par Logical
\par 
\par \b See Also\plain\fs20  - \uldb _WTitle\plain\fs20 {\v CSB8NC}, \uldb Invalid whandles\plain\fs20 {\v 0ZFR8E}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0051}
{\up $}{\footnote\pard\plain{\up $} _WShow}
{\up #}{\footnote\pard\plain{\up #} BRJWRK}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _WShow}
\b _WShow( )
\par \pard \plain\fs20 
\par Displays the specified hidden window at its last position.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b llresult = _WShow(nWhandle)
\par 
\par nWhandle
\par \plain\fs20 
\par The window\f251 \'92\f11 s whandle.
\par 
\par \b Returns\plain\fs20 
\par 
\par Logical
\par 
\par \b See Also\plain\fs20  - \uldb _WHide\plain\fs20 {\v 1R9WWJY}, \uldb Invalid whandles\plain\fs20 {\v 0ZFR8E}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0052}
{\up $}{\footnote\pard\plain{\up $} _WSize}
{\up #}{\footnote\pard\plain{\up #} BRJY29}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _WSize;columns;rows}
\b _WSize( )
\par \pard \plain\fs20 
\par Sets the specified window to the supplied number of columns and rows.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b llresult = _WSize(nWhandle, nCols, nRows)
\par 
\par nWhandle
\par \plain\fs20 
\par The window\f251 \'92\f11 s whandle.
\par 
\par \f2\b nCols\plain\fs20 
\par 
\par The number of columns in the window\f251 \'92\f11 s width.
\par 
\par \f2\b nRows\plain\fs20 
\par 
\par The number of rows in the window\f251 \'92\f11 s height.
\par 
\par \b Returns\plain\fs20 
\par 
\par Logical
\par 
\par \b Remarks
\par \plain\fs20 
\par This function works on both edit windows and forms.
\par 
\par \b See Also\plain\fs20  - \uldb _WSizeP\plain\fs20 {\v 1S9Z_KC}, \uldb Invalid whandles\plain\fs20 {\v 0ZFR8E}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0053}
{\up $}{\footnote\pard\plain{\up $} _WSizeP}
{\up #}{\footnote\pard\plain{\up #} 1S9Z_KC}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _WSizeP;pixels}
\b _WSizeP( )
\par \pard \plain\fs20 
\par Sets the width and height of the specified window to the supplied number of pixels.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b llresult = _WSizeP(nWhandle, nHorzPix, nVertPix)
\par 
\par nWhandle
\par \plain\fs20 
\par The window\f251 \'92\f11 s whandle.
\par 
\par \f2\b nHorzPix\plain\fs20 
\par 
\par The number of pixels in the width.
\par 
\par \f2\b nVertPix\plain\fs20 
\par 
\par The number of pixels in the height.
\par 
\par \b Returns\plain\fs20 
\par 
\par Logical
\par 
\par \b Remarks
\par \plain\fs20 
\par This function works on both edit windows and forms.
\par 
\par \b See Also\plain\fs20  - \uldb _WSize\plain\fs20 {\v BRJY29}, \uldb Invalid whandles\plain\fs20 {\v 0ZFR8E}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0054}
{\up $}{\footnote\pard\plain{\up $} _WTitle}
{\up #}{\footnote\pard\plain{\up #} CSB8NC}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _WTitle;title}
\b _WTitle( )
\par \pard \plain\fs20 
\par Returns the title of the specified window.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b lctitle = _WTitle(nWhandle)
\par 
\par nWhandle
\par \plain\fs20 
\par The window\f251 \'92\f11 s whandle.
\par 
\par \b Returns\plain\fs20 
\par 
\par Character
\par 
\par \b See Also\plain\fs20  - \uldb _WSetTitle\plain\fs20 {\v EP5QYU}, \uldb Invalid whandles\plain\fs20 {\v 0ZFR8E}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0055}
{\up $}{\footnote\pard\plain{\up $} _WTop}
{\up #}{\footnote\pard\plain{\up #} FTWTOP}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _WTop;row}
\b _WTop( )
\par \pard \plain\fs20 
\par Returns the top row location of the specified window.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b lntop = _WTop(nWhandle)
\par 
\par nWhandle
\par \plain\fs20 
\par The window\f251 \'92\f11 s whandle.
\par 
\par \b Returns\plain\fs20 
\par 
\par Numeric
\par 
\par \b See Also\plain\fs20  - \uldb _WTopP\plain\fs20 {\v BRL3SD}, \uldb Invalid whandles\plain\fs20 {\v 0ZFR8E}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0056}
{\up $}{\footnote\pard\plain{\up $} _WTopP}
{\up #}{\footnote\pard\plain{\up #} BRL3SD}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _WTopP;pixel}
\b _WTopP( )
\par \pard \plain\fs20 
\par Returns the top pixel location of the specified window.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b lntop = _WTopP(nWhandle)
\par 
\par nWhandle
\par \plain\fs20 
\par The window\f251 \'92\f11 s whandle.
\par 
\par \b Returns\plain\fs20 
\par 
\par Numeric
\par 
\par \b See Also\plain\fs20  - \uldb _WTop\plain\fs20 {\v FTWTOP}, \uldb Invalid whandles\plain\fs20 {\v 0ZFR8E}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0057}
{\up $}{\footnote\pard\plain{\up $} _WWidth}
{\up #}{\footnote\pard\plain{\up #} CVASVF}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _WWidth;columns}
\b _WWidth( )
\par \pard \plain\fs20 
\par Returns the width of the specified window in terms of columns.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b lnwidth = _WWidth(nWhandle)
\par 
\par nWhandle
\par \plain\fs20 
\par The window\f251 \'92\f11 s whandle.
\par 
\par \b Returns\plain\fs20 
\par 
\par Numeric
\par 
\par \b See Also\plain\fs20  - \uldb _WWidthP\plain\fs20 {\v 86P8PY}, \uldb Invalid whandles\plain\fs20 {\v 0ZFR8E}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0058}
{\up $}{\footnote\pard\plain{\up $} _WWidthP}
{\up #}{\footnote\pard\plain{\up #} 86P8PY}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _WWidthP;pixels}
\b _WWidthP( )
\par \pard \plain\fs20 
\par Returns the width of the specified window in terms of pixels.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b lnwidth = _WWidthP(nWhandle)
\par 
\par nWhandle
\par \plain\fs20 
\par The window\f251 \'92\f11 s whandle.
\par 
\par \b Returns\plain\fs20 
\par 
\par Numeric
\par 
\par \b See Also\plain\fs20  - \uldb _WWidth\plain\fs20 {\v CVASVF}, \uldb Invalid whandles\plain\fs20 {\v 0ZFR8E}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0059}
{\up $}{\footnote\pard\plain{\up $} _WZoom}
{\up #}{\footnote\pard\plain{\up #} BRR3RA}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} _WZoom;maximize;minimize}
\b _WZoom( )
\par \pard\tx355 \plain\fs20 
\par Minimizes, maximizes, or returns the specified window to a normal state.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b llresult = _WZoom(nWhandle, nNewState)
\par 
\par nWhandle
\par \plain\fs20 
\par The window\f251 \'92\f11 s whandle.
\par 
\par \f2\b nNewState\plain\fs20 
\par 
\par The new state of the window. The declares for the valid values are:
\par 
\par \f2\b #DEFINE WZ_MAXIMIZED\tab 0
\par #DEFINE WZ_NORMAL\tab \tab 1
\par #DEFINE WZ_MINIMIZED\tab 2
\par \plain\fs20 
\par \b Returns\plain\fs20 
\par 
\par Logical
\par 
\par \b See Also\plain\fs20  - \uldb Invalid whandles\plain\fs20 {\v 0ZFR8E}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:005a}
{\up $}{\footnote\pard\plain{\up $} AddBS}
{\up #}{\footnote\pard\plain{\up #} 14EGS1W}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} AddBS}
\b AddBS( )
\par \pard \plain\fs20 
\par This function adds a backslash, if required, to an existing path name.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b lcpath = AddBS(cPath)\plain\i\fs20 
\par \plain\fs20 
\par \f2\b cPath\plain\fs20 
\par 
\par A character string specifying the path name to which to add the backslash.
\par 
\par \b Return Type
\par \plain\fs20 
\par Character
\par 
\par \b Examples\plain\fs20 
\par 
\par \f2\b lcoldpath = \'93C:\'5cWINDOWS\'94
\par lcnewpath = AddBS(lcoldpath)
\par ? lcnewpath && Displays \'93C:\'5cWINDOWS\'5c\'94
\par 
\par lcoldpath = \'93C:\'5cWINDOWS\'5c\'94
\par lcnewpath = AddBS(lcoldpath)
\par ? lcnewpath && Displays \'93C:\'5cWINDOWS\'5c\'94
\par \pard \plain\fs20 
\par \b Note\plain\fs20  
\par 
\par This function has been added to the language proper in version 6.0.
\par 
\par \b See Also - \uldb \plain\uldb\fs20 CleanPath\plain\fs20 {\v C1HUI2}, \uldb DefaultExt\plain\fs20 {\v JCX88A}, \uldb DriveType\plain\fs20 {\v 074B7F}, \uldb ForceExt\plain\fs20 {\v 36PZ07N}, \uldb ForcePath\plain\fs20 {\v H1ZPGF}, \uldb JustDrive\plain\fs20 {\v OPGGH3}, \uldb JustExt\plain\fs20 {\v 2EALD5}, \uldb JustFName\plain\fs20 {\v 2QC._Z8}, \uldb JustPath\plain\fs20 {\v CQ2YEC}, \uldb JustStem\plain\fs20 {\v CQ6A6H}, \uldb MkDir\plain\fs20 {\v BHBSLF}, \uldb RmDir\plain\fs20 {\v BMDSLF}, \uldb ValidPath\plain\fs20 {\v 36PDQE}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:005b}
{\up $}{\footnote\pard\plain{\up $} CallFN}
{\up #}{\footnote\pard\plain{\up #} 211_Z8Q}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} CallFN;DLL}
\b CallFN( )
\par \pard \plain\fs20 
\par Executes a call to a DLL function that has been previously registered by RegFN or RegFN32.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b lretval = CallFN(nFunctionHandle[, [@]Parm1[, [@]Parm2[,..[@]ParmN]]])
\par \plain\fs20 
\par \f2\b nFunctionHandle\plain\fs20 
\par 
\par The value returned when the function was registered by the call of \b RegFN()\plain\fs20  or \b RegFN32()\plain\fs20 .
\par 
\par \f2\b Parm1, Parm2,\'85ParmN\plain\fs20 
\par 
\par The parameter list as described when the function was registered. To pass a null use 0. Note that to pass arguments by reference, immediately precede the value with the @ symbol just as you would if you were passing a value to a UDF.
\par \pard 
\par \b Example\plain\fs20 
\par 
\par \f2\b * The following code retrieves the title bar of a window.
\par * Assumes that lnhandle is a known window handle value.
\par lngettext = RegFN(\'93GetWindowText\'94, \'93I@CI\'94, \'93I\'94)
\par lcbuffer = SPCACE(100) + CHR(0)
\par lnlength = LEN(lcbuffer)
\par lnlength = CallFN(lngettext, lnhandle, @lcbuffer, lnlength)
\par \plain\fs20 
\par \b See Also\plain\fs20  - \uldb RegFN\plain\fs20 {\v BM.VIB}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:005c}
{\up $}{\footnote\pard\plain{\up $} CleanPath}
{\up #}{\footnote\pard\plain{\up #} C1HUI2}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} CleanPath}
\b CleanPath( )
\par \pard \plain\fs20 
\par Returns a corrected a file name where characters, which would be invalid in DOS, duplicate backslashes, spaces, etc., are removed. No guarantee is made that the filename is completely legal or that the file or directory exists. Extra characters beyond the 8 of the primary filename, and 3 of the extension are removed.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b lcfilename = CleanPath(cFilename)
\par \plain\i\fs20 
\par \plain\f2\b\fs20 cFilename
\par \plain\fs20 
\par A character string specifying the file and/or directory name to be cleaned.
\par \pard 
\par \b Return Types\plain\fs20 
\par 
\par Character
\par 
\par \b See Also - \uldb \plain\uldb\fs20 AddBS\plain\fs20 {\v 14EGS1W}, \uldb DefaultExt\plain\fs20 {\v JCX88A}, \uldb DriveType\plain\fs20 {\v 074B7F}, \uldb ForceExt\plain\fs20 {\v 36PZ07N}, \uldb ForcePath\plain\fs20 {\v H1ZPGF}, \uldb JustDrive\plain\fs20 {\v OPGGH3}, \uldb JustExt\plain\fs20 {\v 2EALD5}, \uldb JustFName\plain\fs20 {\v 2QC._Z8}, \uldb JustPath\plain\fs20 {\v CQ2YEC}, \uldb JustStem\plain\fs20 {\v CQ6A6H}, \uldb MkDir\plain\fs20 {\v BHBSLF}, \uldb RmDir\plain\fs20 {\v BMDSLF}, \uldb ValidPath\plain\fs20 {\v 36PDQE}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:005d}
{\up $}{\footnote\pard\plain{\up $} CloseClip}
{\up #}{\footnote\pard\plain{\up #} LI4.7L}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} CloseClip}
\b CloseClip( )
\par \pard \plain\fs20 
\par Closes the Clipboard. The Clipboard should have been previously opened previously with \uldb \b OpenClip\plain\b\fs20 {\v 7XJE.L}\plain\fs20 .
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b llresult = CloseClip()
\par \plain\fs20 
\par \b Return Type\plain\fs20 
\par 
\par Logical
\par 
\par \b Remarks\plain\fs20 
\par 
\par The return value indicates whether or not the function succeeded in closing the clipboard (.T.) or failed (.F.). Most Clip functions rely on opening the Clipboard before using.  _CLIPTEXT can be used to store and retrieve the contents of the Windows Clipboard.  The format of the _CLIPTEXT variable, however, is limited to text.
\par \pard 
\par \b Note\plain\fs20    
\par 
\par This function maps to the Windows API function \b CloseClipboard\plain\fs20 . For more information, see the Windows API documentation for this function.
\par 
\par \b See Also\plain\fs20  - \uldb CountClipF\plain\fs20 {\v 54EH_S9}, \uldb EmptyClip\plain\fs20 {\v 11NJOWG}, \uldb EnumClipFm\plain\fs20 {\v 12SSV0G}, \uldb GetClipDat\plain\fs20 {\v _708YP}, \uldb GetClipFmt\plain\fs20 {\v 3N0K8YJ}, \uldb IsClipFmt\plain\fs20 {\v 1HSGYXC}, \uldb OpenClip\plain\fs20 {\v 7XJE.L}, \uldb RegClipFmt\plain\fs20 {\v 1GPWPV0}, \uldb SetClipDat\plain\fs20 {\v LSILHM}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:005e}
{\up $}{\footnote\pard\plain{\up $} CountClip}
{\up #}{\footnote\pard\plain{\up #} 54EH_S9}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} CountClip}
\b CountClipF( )
\par \pard \plain\fs20 
\par Returns the number of different data formats currently contained in the Windows Clipboard.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b lnformats = CountClipF()\plain\i\fs20 
\par \plain\fs20 
\par \b Return Type\plain\fs20 
\par 
\par Numeric
\par 
\par \b Remarks\plain\fs20 
\par 
\par Most Clipboard functions rely on opening it before using.  _CLIPTEXT can be used to store and retrieve the contents of the Windows Clipboard.  The format of the _CLIPTEXT variable, however, is limited to text.
\par 
\par \b Note\plain\fs20    
\par 
\par This function maps to the Windows API function \b CountClipboardFormats\plain\fs20 . For more information, see the Windows API documentation for this function.
\par \pard 
\par \b See Also\plain\fs20  - \uldb CloseClip\plain\fs20 {\v LI4.7L}, \uldb EmptyClip\plain\fs20 {\v 11NJOWG}, \uldb EnumClipFm\plain\fs20 {\v 12SSV0G}, \uldb GetClipDat\plain\fs20 {\v _708YP}, \uldb GetClipFmt\plain\fs20 {\v 3N0K8YJ}, \uldb IsClipFmt\plain\fs20 {\v 1HSGYXC}, \uldb OpenClip\plain\fs20 {\v 7XJE.L}, \uldb RegClipFmt\plain\fs20 {\v 1GPWPV0}, \uldb SetClipDat\plain\fs20 {\v LSILHM}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:005f}
{\up $}{\footnote\pard\plain{\up $} DefaultExt}
{\up #}{\footnote\pard\plain{\up #} JCX88A}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} DefaultExt}
\b DefaultExt( )
\par \pard \plain\fs20 
\par Returns a file name with a new extension if it doesn't already exist. If the file has an existing extension, it remains unchanged
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b lcfilename = DefaultExt(cFilename, cDefault)\plain\fs20 
\par \i 
\par \plain\f2\b\fs20 cFilename
\par \plain\fs20 
\par A character string specifying the filename to be returned. This may or may not include the path and extension.
\par 
\par \f2\b cDefault
\par \plain\fs20 
\par A character string specifying the default extension without a period.
\par 
\par \b Return Type\plain\fs20 
\par 
\par Character
\par 
\par \pard \b Examples\plain\fs20 
\par 
\par \f2\b lcfilename = \'93MYFILE.TXT\'94
\par lcfilename = DefaultExt(lcfilename, \'93DBF\'94) && Returns \'93MYFILE.TXT\'94
\par lcfilename = \'93MYFILE\'94
\par lcfilename = DefaultExt(lcfilename, \'93DBF\'94) && Returns \'93MYFILE.DBF\'94
\par \plain\fs20 
\par \b Note\plain\fs20 
\par 
\par This function has been added to the language proper in version 6.0.
\par 
\par \b See Also\plain\fs20  - \uldb AddBS\plain\fs20 {\v 14EGS1W}, \uldb CleanPath\plain\fs20 {\v C1HUI2}, \uldb DriveType\plain\fs20 {\v 074B7F}, \uldb ForceExt\plain\fs20 {\v 36PZ07N}, \uldb ForcePath\plain\fs20 {\v H1ZPGF}, \uldb JustDrive\plain\fs20 {\v OPGGH3}, \uldb JustExt\plain\fs20 {\v 2EALD5}, \uldb JustFName\plain\fs20 {\v 2QC._Z8}, \uldb JustPath\plain\fs20 {\v CQ2YEC}, \uldb JustStem\plain\fs20 {\v CQ6A6H}, \uldb MkDir\plain\fs20 {\v BHBSLF}, \uldb RmDir\plain\fs20 {\v BMDSLF}, \uldb ValidPath\plain\fs20 {\v 36PDQE}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0060}
{\up $}{\footnote\pard\plain{\up $} DriveType}
{\up #}{\footnote\pard\plain{\up #} 074B7F}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} DriveType}
\b DriveType( )
\par \pard\tx355 \plain\fs20 
\par Returns the type (floppy, fixed, network, RAM, etc.) of the specified drive.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b lndrivetype = DriveType(cDrive)
\par 
\par cDrive
\par \plain\fs20 
\par A character string specifying the drive letter designation. This may or may not include the colon following the letter (e.g. \'93C:\'94).
\par 
\par \b Return Type\plain\fs20 
\par 
\par Numeric
\par 
\par \b Remarks\plain\fs20 
\par 
\par Listed below are the values that \b DriveType\plain\fs20  returns and the corresponding description of the drive.
\par 
\par \b Value\tab \plain\fs20 \tab \tab \b Type\plain\fs20 
\par \pard\tx355 0 \tab \tab \tab No type
\par 2\tab \tab \tab Floppy disk drive
\par 3\tab \tab \tab Fixed hard disk drive
\par 4\tab \tab \tab Network drive or other removable type
\par 5\tab \tab \tab CD-ROM drive
\par 6\tab \tab \tab RAM disk (Due to differing types, result may be inconsistent.)
\par 
\par \b Examples\plain\fs20 
\par 
\par The examples below reflect a common computer configuration.
\par 
\par \f2\b lndrivetype = DriveType(\'93A\'94) && Returns 2 - Removable floppy drive.
\par lndrivetype = DriveType(\'93C:\'94) && Returns 3 - Non-removable hard drive.
\par lndrivetype = DriveType(\'93D\'94) && Returns 5 - CD ROM drive.
\par \pard\tx355 lndrivetype = DriveType(\'93F:\'94) && Returns 4 - Network drive.
\par \plain\fs20 
\par \b Notes\plain\fs20 
\par 
\par This function maps to the \b GetDriveType\plain\fs20  Windows API function.
\par 
\par This function has been added to the language proper in version 6.0.
\par 
\par \b See Also\plain\fs20  - \uldb AddBS\plain\fs20 {\v 14EGS1W}, \uldb CleanPath\plain\fs20 {\v C1HUI2}, \uldb DefaultExt\plain\fs20 {\v JCX88A}, \uldb ForceExt\plain\fs20 {\v 36PZ07N}, \uldb ForcePath\plain\fs20 {\v H1ZPGF}, \uldb JustDrive\plain\fs20 {\v OPGGH3}, \uldb JustExt\plain\fs20 {\v 2EALD5}, \uldb JustFName\plain\fs20 {\v 2QC._Z8}, \uldb JustPath\plain\fs20 {\v CQ2YEC}, \uldb JustStem\plain\fs20 {\v CQ6A6H}, \uldb MkDir\plain\fs20 {\v BHBSLF}, \uldb RmDir\plain\fs20 {\v BMDSLF}, \uldb ValidPath\plain\fs20 {\v 36PDQE}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0061}
{\up $}{\footnote\pard\plain{\up $} EmptyClip}
{\up #}{\footnote\pard\plain{\up #} 11NJOWG}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} EmptyClip}
\b EmptyClip( )
\par \pard \plain\fs20 
\par Removes the contents of the Clipboard and frees handles to data in it. It then assigns ownership of the Clipboard to the window in which it is open.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b llresult = EmptyClip()
\par \plain\fs20 
\par \b Return Type\plain\fs20 
\par 
\par Logical
\par 
\par \b Remarks\plain\fs20 
\par 
\par Most Clip functions rely on opening the Clipboard before using.  _CLIPTEXT can be used to store and retrieve the contents of the Windows Clipboard.  The format of the _CLIPTEXT variable, however, is limited to text.
\par 
\par \pard \b Note\plain\fs20    
\par 
\par This function maps to the Windows API function \b EmptyClipboard\plain\fs20 . For more information, see the Windows API documentation for this function.
\par 
\par \b See Also\plain\fs20  - \uldb CloseClip\plain\fs20 {\v LI4.7L}, \uldb CountClipF\plain\fs20 {\v 54EH_S9}, \uldb EnumClipFm\plain\fs20 {\v 12SSV0G}, \uldb GetClipDat\plain\fs20 {\v _708YP}, \uldb GetClipFmt\plain\fs20 {\v 3N0K8YJ}, \uldb IsClipFmt\plain\fs20 {\v 1HSGYXC}, \uldb OpenClip\plain\fs20 {\v 7XJE.L}, \uldb RegClipFmt\plain\fs20 {\v 1GPWPV0}, \uldb SetClipDat\plain\fs20 {\v LSILHM}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0062}
{\up $}{\footnote\pard\plain{\up $} EnumClipFm}
{\up #}{\footnote\pard\plain{\up #} 12SSV0G}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} EnumClipFm}
\b EnumClipFm( )
\par \pard \plain\fs20 
\par Enumerates the formats currently found of those on the Clipboard. This information is stored in an ordered list of formats.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b lnformat = EnumClipFm(nFormat)
\par 
\par nFormat
\par \plain\fs20 
\par A numerical value specifying a Clipboard format.
\par 
\par To determine the current formats currently stored in the Clipboard, initially set nFormat to 0.
\par \b EnumClipFm( ) \plain\fs20 will then return the first available format. Subsequent calls to \b EnumClipFm( )\plain\fs20 , should pass the value previously returned. See \uldb GetClipDat\plain\fs20 {\v _708YP} for a table of the meaning of the return values.
\par \pard 
\par \b Return Type\plain\fs20 
\par 
\par Numeric
\par 
\par \b Remarks\plain\fs20 
\par 
\par Each call to \b EnumClipFm()\plain\fs20  should specify a known available format. The function returns the next available format that appears in the list.
\par 
\par Like most clipboard functions, \b EnumClipFm()\plain\fs20  relies on opening the Clipboard before calling.  _CLIPTEXT can be used to store and retrieve the contents of the Windows Clipboard.  The format of the _CLIPTEXT variable, however, is limited to text.
\par 
\par \b Note\plain\fs20    
\par \pard 
\par This function maps to the Windows API function \b EnumClipboardFormats\plain\fs20 . For more information, see the Windows API documentation for this function.
\par 
\par \b See Also\plain\fs20  -\uldb  CloseClip\plain\fs20 {\v LI4.7L}, \uldb CountClipF\plain\fs20 {\v 54EH_S9}, \uldb EmptyClip\plain\fs20 {\v 11NJOWG}, \uldb GetClipDat\plain\fs20 {\v _708YP}, \uldb GetClipFmt\plain\fs20 {\v 3N0K8YJ}, \uldb IsClipFmt\plain\fs20 {\v 1HSGYXC}, \uldb OpenClip\plain\fs20 {\v 7XJE.L}, \uldb RegClipFmt\plain\fs20 {\v 1GPWPV0}, \uldb SetClipDat\plain\fs20 {\v LSILHM}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0063}
{\up $}{\footnote\pard\plain{\up $} ForceExt}
{\up #}{\footnote\pard\plain{\up #} 36PZ07N}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} ForceExt}
\b ForceExt( )
\par \pard \plain\fs20 
\par Returns a string containing a filename with a new extension.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b lcfilename = ForceExt(cFilename, cExtension)
\par \plain\i\fs20 
\par \plain\f2\b\fs20 cFilename\plain\i\fs20 
\par \plain\fs20 
\par A character string specifying the filename to use as a basis for the return value. This filename may or may not contain the fully qualified path. Further the filename may or may not necessarily have an existing extension.
\par 
\par \f2\b cExtension
\par \plain\fs20 
\par A character string specifying the new extension for the filename. Do not include a period preceding this value.
\par \pard 
\par \b Return Type\plain\fs20 
\par 
\par Character
\par 
\par \b Examples
\par \plain\fs20 
\par \b ForceExt()\plain\fs20  provides an easy way to create new filenames, based on existing files for output. The examples below show how to use the name of an existing report file for the basis of a new filename for text or spreadsheet output.
\par 
\par \f2\b lcrptname = \'93Myreport.frx\'94
\par lctxtfile = ForceExt(lcrptname, \'93TXT\'94) && returns Myreport.TXT
\par lcxlsfile = ForceExt(lcrptname, \'93XLS\'94) && returns Myreport.XLS
\par \plain\fs20 
\par \b Note\plain\fs20 
\par \pard 
\par This function has been added to the language proper in version 6.0.
\par 
\par \b See Also\plain\fs20  -\uldb  AddBS\plain\fs20 {\v 14EGS1W}, \uldb CleanPath\plain\fs20 {\v C1HUI2}, \uldb DefaultExt\plain\fs20 {\v JCX88A}, \uldb DriveType\plain\fs20 {\v 074B7F}, \uldb ForcePath\plain\fs20 {\v H1ZPGF}, \uldb JustDrive\plain\fs20 {\v OPGGH3}, \uldb JustExt\plain\fs20 {\v 2EALD5}, \uldb JustFName\plain\fs20 {\v 2QC._Z8}, \uldb JustPath\plain\fs20 {\v CQ2YEC}, \uldb JustStem\plain\fs20 {\v CQ6A6H}, \uldb MkDir\plain\fs20 {\v BHBSLF}, \uldb RmDir\plain\fs20 {\v BMDSLF}, \uldb ValidPath\plain\fs20 {\v 36PDQE}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0064}
{\up $}{\footnote\pard\plain{\up $} ForcePath}
{\up #}{\footnote\pard\plain{\up #} H1ZPGF}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} ForcePath}
\b ForcePath( )
\par \pard \plain\fs20 
\par Returns a file name with a new path name substituted for the old one.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b lcnewpath = ForcePath(cFilename, cPath)
\par \plain\i\fs20 
\par \plain\f2\b\fs20 cFilename
\par \plain\fs20 
\par A character string specifying the filename to use as a basis for the return value. This filename may or may not contain the fully qualified path. Further the filename may or may not necessarily have an existing extension.
\par 
\par \f2\b cPath
\par \plain\fs20 
\par A character string specifying the new path value to use for cFilename.
\par \pard 
\par \b Return Type\plain\fs20 
\par 
\par Character
\par 
\par \b Examples\plain\fs20 
\par 
\par \b ForcePath() \plain\fs20 is especially useful in situations where an existing file is being copied to a new destination. The examples below use the Samples subdirectory as a source and the A: drive as a target.
\par 
\par \f2\b lcorgfile = \'93C:\'5cVFP\'5cSAMPLES\'5cANYTABLE.DBF\'94
\par lcnewfile = ForcePath(lcorgfile, \f251 \'91\f2 A:\'5c\'94) && Returns A:\'5cANYTABLE.DBF
\par COPY FILE (lcorgfile) TO (lcnewfile)
\par \plain\fs20 
\par \b Note\plain\fs20 
\par 
\par This function has been added to the language proper in version 6.0.
\par \pard 
\par \b See Also\plain\fs20  -\uldb  AddBS\plain\fs20 {\v 14EGS1W}, \uldb CleanPath\plain\fs20 {\v C1HUI2}, \uldb DefaultExt\plain\fs20 {\v JCX88A}, \uldb DriveType\plain\fs20 {\v 074B7F}, \uldb ForceExt\plain\fs20 {\v 36PZ07N}, \uldb JustDrive\plain\fs20 {\v OPGGH3}, \uldb JustExt\plain\fs20 {\v 2EALD5}, \uldb JustFName\plain\fs20 {\v 2QC._Z8}, \uldb JustPath\plain\fs20 {\v CQ2YEC}, \uldb JustStem\plain\fs20 {\v CQ6A6H}, \uldb MkDir\plain\fs20 {\v BHBSLF}, \uldb RmDir\plain\fs20 {\v BMDSLF}, \uldb ValidPath\plain\fs20 {\v 36PDQE}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0065}
{\up $}{\footnote\pard\plain{\up $} FoxToolVer}
{\up #}{\footnote\pard\plain{\up #} 31VC9DH}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} FoxToolVer}
\b FoxToolVer( )
\par \pard \plain\fs20 
\par Returns the version number of the Foxtools library.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b lcversion = FoxToolVer()
\par \plain\fs20 
\par \b Return Type\plain\fs20 
\par 
\par Character
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0066}
{\up $}{\footnote\pard\plain{\up $} FoxTouch}
{\up #}{\footnote\pard\plain{\up #} I_4KEX}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} FoxTouch}
\b FoxTouch( )
\par \pard \plain\fs20 
\par Modifies the date/time stamp of a specified file.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b lnresult = FoxTouch(lcFilename, lnYear, lnMonth, lnDay,;
\par   lnHours, lnMinutes, lnSeconds)\plain\fs20 
\par 
\par \f2\b lcFilename\plain\fs20 
\par 
\par A character string representing the fully qualified file name.
\par 
\par \f2\b lnYear\plain\fs20 
\par 
\par The 4 digit numeric value of the year.
\par 
\par \f2\b lnMonth\plain\fs20 
\par 
\par The numeric month (1 - 12).
\par 
\par \f2\b lnDay\plain\fs20 
\par 
\par The day number within the month.
\par 
\par \f2\b lnHours\plain\fs20 
\par 
\par The hour number (0 - 23) of the day.
\par \pard 
\par \f2\b lnMinutes\plain\fs20 
\par 
\par The minute number of the hour (0 - 59).
\par 
\par \f2\b lnSeconds\plain\fs20 
\par 
\par The number of seconds (0 - 59).
\par 
\par \b Returns\plain\fs20 
\par 
\par Numeric
\par 
\par \b Remarks\plain\fs20 
\par 
\par The function always appears to return 0 even if the file does not exist. According to the documentation, if no date is passed the function uses the system date and time. Unfortunately, this is inaccurate. Calling \b FoxTouch() \plain\fs20 in VFP 5.0/6.0 without first providing it with the desired all parameters results in a data type mismatch error. If, however, you provide the parameters, any call to FoxTouch() after the initial one, that does not provide the parameters, will cause the function to use the previously provided ones.
\par \pard 
\par Further, in 5.0/6.0 the function apparently assumes that the value being passed is in UTC (Universal Coordinated Time) time, and stamps the file accordingly. In the Eastern time zone of the United States, this will cause the file to receive a last modification date/time that is 4 (under Daylight Savings Time) or 5 hours (under Standard Time) earlier than the desired value. Naturally, other time zones will receive different results. There are three possible workarounds for this problem. One is to retrieve the key HKEY_LOCAL_MACHINE\'5cSystem\'5cCurrentControlSet\'5ccontrol\'5cTimeZoneInformation\'5cActiveTimeBias from the registry as a string and convert it to the value in minutes. The second is to retrieve the current bias from GetTimeZoneInformation(). The second example demonstrates this technique.
\par \pard 
\par \b Example\plain\fs20 
\par 
\par The following example uses \b FoxTouch()\plain\fs20  to terminate an executable after 30 days of usage. It increments the seconds to keep track of the number of days. If 30 days have elapsed since the first usage, the function returns .T. The function is written for usage under VFP. FPW users should modify the function due to the absence of the \b DATETIME()\plain\fs20  function. The function, however, is not foolproof, since it can be overcome by modifying the system date. Further, it relies on the fact that the seconds are not shown in the Windows 95 Explorer.
\par \pard 
\par \f2\b FUNCTION ThirtyDays
\par 
\par LPARAMETER pcfile
\par * pcfile is the fully qualified file name
\par 
\par LOCAL a_dir, lnyear, lnday, lnmonth, lnhour, lnmin, lnsecs,;
\par   llresult, lnfiles, ldtoday
\par * Set return value so that if the file is not present
\par * the program will not run.
\par llresult = .T.
\par IF FILE(pcfile)
\par   = ADIR(a_dir, pcfile)
\par   lnyear = YEAR(a_dir[1, 3])
\par   ldtoday = DATETIME()
\par   IF lnyear = 1980
\par     * First use, so stamp it with the current
\par     * date and time with seconds at 0
\par \pard     lnyear = YEAR(ldtoday)
\par     lnmonth = MONTH(ldtoday)
\par     lnday = DAY(ldtoday)
\par     lnhour = HOUR(ldtoday)
\par     lnmin = MINUTE(ldtoday)
\par     lnsec = 0
\par   ELSE
\par     * Otherwise, modify the seconds
\par     * if necessary
\par     lnmonth = MONTH(a_dir[1, 3])
\par     lnday = DAY(a_dir[1, 3])
\par     lnhour = VAL(LEFT(a_dir[1, 4], 2))
\par     lnmin = VAL(SUBSTR(a_dir[1, 4], 3, 2))
\par     lnsec = VAL(RIGHT(a_dir[1, 4], 2))
\par     IF DATE() > a_dir[1, 3] + lnsecs
\par       lnsec = lnsec + 1
\par     ENDIF
\par \pard     llresult = (lnsec = 30)
\par   ENDIF
\par   = FoxTouch(pcfile, lnyear, lnmonth, lnday, lnhour, lnmin, lnsec)
\par ENDIF
\par RETURN llresult
\par \plain\fs20 
\par The following example demonstrates how to call GetTimeZoneInformation() to retrieve the current bias and overcome the bug mentioned above. This applies to the 6.0 version of the library. Early or later releases should be tested prior to use.
\par 
\par \f2\b FUNCTION FoxStamp
\par   Adjusts for the FoxTouch() UTC bug
\par 
\par   LPARAMETER tfilename, ttDateTime
\par \pard   The file to stamp
\par \pard\li235 A date/time to stamp it with
\par \pard 
\par DECLARE INTEGER GetTimeZoneInformation IN Win32API;
\par   STRING @lpTimeZoneInformation
\par LOCAL lctimezone, lnbias, ltdatetime
\par lctimezone = REPLICATE(CHR(0), 172)
\par = GetTimeZoneInformation(@lctimezone)
\par * Convert to and integer number of seconds to add or subtract
\par lnbias = StringToInteger(LEFT(lctimezone, 4, .T.) * 60
\par ltdatetime = ttDateTime + lnbias
\par RETURN FoxTouch(tfilename, YEAR(ltdatetime), MONTH(ltdatetime),;
\par   DAY(ltdatetime), HOUR(ltdatetime), MINUTE(ltdatetime),;
\par \pard   SEC(ltdatetime))
\par 
\par FUNCTION StringToInteger
\par     
\par   LPARAMETER pcstring, plsigned
\par 
\par LOCAL lnresult, lnlast, lni, llsigned,;
\par   lnmsb, lnmax
\par lnresult = 0
\par lnlast = LEN(pcstring)
\par * Return Signed Integer?
\par IF PCOUNT() = 2
\par   llsigned = plsigned
\par ELSE
\par   llsigned = .F.
\par ENDIF
\par FOR lni = 1 TO lnlast
\par   lnresult = lnresult + ASC(SUBSTR(pcstring, lni, 1)) * (256 ^ (lni - 1))
\par NEXT
\par IF llsigned
\par   lnmsb = (lnlast * 8) - 1
\par   IF BITTEST(lnresult, lnmsb)
\par     lnmax = (2 ^ (lnmsb + 1))
\par \pard     lnresult = lnresult - lnmax
\par   ENDIF
\par ENDIF
\par RETURN lnresult
\par \plain\fs20 
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0067}
{\up $}{\footnote\pard\plain{\up $} GetClipDat}
{\up #}{\footnote\pard\plain{\up #} _708YP}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} GetClipDat}
\b GetClipDat( )
\par \pard\tx355 \plain\fs20 
\par Returns a handle for the Clipboard data of a specified format. The caller should determine, prior to the call that the format currently exists on the Clipboard.
\par 
\par \b Syntax
\par \plain\fs20 
\par \f2\b lnhandle = GetClipDat(nFormat)
\par \plain\fs20 
\par \f2\b nFormat
\par \plain\fs20 
\par A numeric value which should be one of the following available format values:
\par 
\par \b nFormat\tab Description (define type)
\par \plain\fs20 1\tab \tab cf_Text
\par 2\tab \tab cf_Bitmap
\par 3\tab \tab cf_MetaFilePict
\par 4\tab \tab cf_SYLK
\par 5\tab \tab cf_DIF
\par 6\tab \tab cf_TIFF
\par 7\tab \tab cf_OEMText
\par \pard\tx355 8\tab \tab cf_DIB
\par 9\tab \tab cf_Palette
\par 
\par \b Return Type
\par \plain\fs20 
\par Logical
\par 
\par \b Remarks\plain\fs20 
\par 
\par Any calling application should be aware that the Clipboard controls the handle. Therefore, the caller should immediately copy the data. Like other Clipboard functions, \b GetClipDat() \plain\fs20 requires that the Clipboard be opened prior to calling. _CLIPTEXT can be used to store and retrieve the contents of the Windows Clipboard.  The format of the _CLIPTEXT variable, however, is limited to text.
\par \pard\tx355 
\par \b Note\plain\fs20    
\par 
\par This function maps to the Windows API function \b GetClipboardData\plain\fs20 . For more information, see the Windows API documentation for this function.
\par 
\par \b See Also \plain\fs20 - \uldb CloseClip\plain\fs20 {\v LI4.7L}, \uldb CountClipF\plain\fs20 {\v 54EH_S9}. \uldb EmptyClip\plain\fs20 {\v 11NJOWG}, \uldb EnumClipFm\plain\fs20 {\v 12SSV0G}, \uldb GetClipFmt\plain\fs20 {\v 3N0K8YJ}, \uldb IsClipFmt\plain\fs20 {\v 1HSGYXC}, \uldb OpenClip\plain\fs20 {\v 7XJE.L}, \uldb RegClipFmt\plain\fs20 {\v 1GPWPV0}, \uldb SetClipDat\plain\fs20 {\v LSILHM}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0068}
{\up $}{\footnote\pard\plain{\up $} GetClipFmt}
{\up #}{\footnote\pard\plain{\up #} 3N0K8YJ}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} GetClipFmt}
\b GetClipFmt( )
\par \pard \plain\fs20 
\par Returns the name of a user registered Clipboard format. This format must not be one of the pre-existing defined types. See \uldb RegClipFmt\plain\fs20 {\v 1GPWPV0} for information on how to register a new Clipboard format.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b lcformat = GetClipFmt(nFormat)
\par \plain\i\fs20 
\par \plain\f2\b\fs20 nFormat
\par \plain\fs20 
\par A numeric value representing the user defined registered format to retrieve. This argument must not specify any of the predefined clipboard formats. See \uldb GetClipDat\plain\fs20 {\v _708YP} for a table of the predefined format values
\par \pard 
\par \b Return Type\plain\fs20 
\par 
\par Character
\par 
\par \b Remarks\plain\fs20 
\par 
\par Like other Clipboard functions, \b GetClipFmt() \plain\fs20 requires that the Clipboard be opened prior to calling. _CLIPTEXT can be used to store and retrieve the contents of the Windows Clipboard.  The format of the _CLIPTEXT variable, however, is limited to text.
\par 
\par \b Notes\plain\fs20    
\par 
\par This function maps to the Windows API function \b GetClipboardFormatName\plain\fs20 . For more information, see the Windows API documentation for this function.
\par \pard 
\par FOXTOOLS.HLP, which ships with Visual FoxPro, indicates that this function\f251 \'92\f11 s return value is numeric. Tests, however, indicate that the value is character, as shown above.
\par 
\par \b See Also \plain\fs20 - \uldb CloseClip\plain\fs20 {\v LI4.7L}, \uldb CountClipF\plain\fs20 {\v 54EH_S9}. \uldb EmptyClip\plain\fs20 {\v 11NJOWG}, \uldb EnumClipFm\plain\fs20 {\v 12SSV0G}, \uldb GetClipDat\plain\fs20 {\v _708YP}, \uldb IsClipFmt\plain\fs20 {\v 1HSGYXC}, \uldb OpenClip\plain\fs20 {\v 7XJE.L}, \uldb RegClipFmt\plain\fs20 {\v 1GPWPV0}, \uldb SetClipDat\plain\fs20 {\v LSILHM}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0069}
{\up $}{\footnote\pard\plain{\up $} GetFileVersion}
{\up #}{\footnote\pard\plain{\up #} IP6OP8}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} GetFileVersion}
\b GetFileVersion( )
\par \pard \plain\fs20 
\par Returns information about a file. In most cases this is either an executable or dynamic link library. The file must be one created for 32 bit Windows.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b lnresult = GetFileVersion(cFileName, @ArrayName)
\par \plain\i\fs20 
\par \plain\f2\b\fs20 cFileName
\par \plain\fs20 
\par A character string representing a fully qualified, if necessary, filename specifying the filename for which information is returned.
\par 
\par \f2\b ArrayName
\par \plain\fs20 
\par The array into which the file information is placed. The array must be DIMENSIONed before calling \b GetFileVersion()\plain\fs20 , and must be at least 12 rows in length. Note that the array must be passed by reference.
\par \pard\tx355 
\par \b Return Type\plain\fs20 
\par 
\par Numeric
\par 
\par \b Remarks\plain\fs20 
\par 
\par If the function call is successful, zero is returned. -1 indicates that the function was unable to retrieve the information.
\par 
\par The following table lists the file information contained in the twelve array elements. Those elements with an asterisk indicate information that may be stored in a Visual FoxPro executable using the Build/Version dialog.
\par 
\par \b Element Number\tab File Information
\par \plain\fs20 1*\tab \tab \tab Comments
\par 2*\tab \tab \tab Company Name
\par \pard\tx355 3*\tab \tab \tab File Description
\par 4*\tab \tab \tab File Version
\par 5\tab \tab \tab Internal Name
\par 6*\tab \tab \tab Legal Copyright
\par 7*\tab \tab \tab Legal Trademarks
\par 8\tab \tab \tab Original File Name
\par 9\tab \tab \tab Private Build
\par 10*\tab \tab \tab Product Name
\par 11\tab \tab \tab Product Version
\par 12\tab \tab \tab Special Build
\par 
\par \b Notes\plain\fs20 
\par 
\par This function is not available in the versions of FOXTOOLS that shipped with FoxPro for Windows 2.x. 
\par 
\par This function has been added to the language proper in version 6.0 as AGETFILEVERSION( ).
\par 
\par This function maps to the Windows API function \b GetFileVersionInfo\plain\fs20 .
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:006a}
{\up $}{\footnote\pard\plain{\up $} GetProStrg}
{\up #}{\footnote\pard\plain{\up #} 19B.QHP}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} GetProStrg}
\b GetProStrg( )
\par \pard \plain\fs20 
\par Retrieves the string associated with an entry in a section of the WIN.INI initialization file.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b lnlength = GetProStrg(lpszSection, lpszEntry, lpszDefault,;
\par @lpszReturnBuffer, cbReturnBuffer)
\par \plain\fs20 
\par \f2\b lpszSection\plain\i\fs20 
\par \plain\fs20 
\par A string indicating the section containing the entry.
\par 
\par \f2\b lpszEntry
\par \plain\fs20 
\par A string indicating the entry whose associated string (indicated by being to the right of the equal sign) is to be retrieved. If this value is NULL (zero should be used to indicate a NULL), all entries (not the strings associated with them) in the section specified by the lpszSection argument are copied to the buffer specified by the lpszReturnBuffer argument. The return buffer will contain the values, separated by CHR(0).
\par \pard 
\par \f2\b lpszDefault\plain\fs20 
\par 
\par A character string representing the default value for the given entry if the entry cannot be found in the initialization file. This argument must never be a .NULL. It must be a valid string, even if it is empty (\'93\'94).
\par 
\par \f2\b lpszReturnBuffer\plain\fs20 
\par 
\par A character string serving as the buffer that will receive the character string. Note that this value must be passed by reference.
\par 
\par \f2\b cbReturnBuffer\plain\fs20 
\par 
\par The length, in characters, of lpszReturnBuffer. 
\par \pard 
\par \b Return Value\plain\fs20 
\par 
\par Numeric
\par 
\par \b Remarks\plain\fs20 
\par 
\par While the FOXTOOLS.HLP file indicates that information from INI files other than WIN.INI can be returned, this is not the case.
\par 
\par If a null is passed and the destination buffer is too small to hold all the entries, the last will be truncated and followed by two terminating null characters (CHR(0)).
\par 
\par If the string associated with lpszEntry is enclosed in quotation marks (either single or double), they are discarded when \b GetProStrg()\plain\fs20  returns the string.
\par \pard 
\par The function is case independent.
\par 
\par If the function is successful, the return value is the number of bytes, not including the terminating CHR(0) copied to the buffer. Zero is returned if the section or entry cannot be found.
\par 
\par \b Notes\plain\fs20 
\par 
\par This function is not available in the versions of FOXTOOLS that shipped with FoxPro for Windows 2.x.
\par 
\par This function maps to the Windows API function \b GetProfileString\plain\fs20 . To retrieve a value from an initialization file other than WIN.INI, use the API function \b GetPrivateProfileString\plain\fs20 .
\par \pard 
\par \b Examples\plain\fs20 
\par 
\par The first example retrieves the entries in entire \'93windows\'94 section. The second, retrieves the value associated with the \'93device\'94 (which is the default printer) entry.
\par 
\par \f2\b * Example 1
\par lcbuffer = SPACE(200)
\par lnlength = LEN(lcbuffer)
\par lnlength = GetProStrg(\f251 \'91\f2 windows\f251 \'92\f2 , 0, \'93\'94, @lcbuffer, lnlength)
\par * Example 2
\par lcbuffer = SPACE(200)
\par lnlength = LEN(lcbuffer)
\par lnlength = GetProStrg(\f251 \'91\f2 windows\f251 \'92\f2 , \f251 \'91\f2 device\f251 \'92\f2 , \'93\'94, @lcbuffer, lnlength)
\par \pard \plain\fs20 
\par \b See Also\plain\fs20  - \uldb PutProStrg\plain\fs20 {\v XDITBE}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:006b}
{\up $}{\footnote\pard\plain{\up $} IsClipFmt}
{\up #}{\footnote\pard\plain{\up #} 1HSGYXC}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} IsClipFmt}
\b IsClipFmt( )
\par \pard \plain\fs20 
\par Indicates whether data of the specified format is currently contained in the Clipboard.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b llresult = IsClipFmt(nFormat)
\par \plain\i\fs20 
\par \plain\f2\b\fs20 nFormat\plain\i\fs20 
\par \plain\fs20 
\par The numeric value of the format of the available data. See \uldb GetClipDat\plain\fs20 {\v _708YP} for a table of the meanings of the predefined values.
\par 
\par \b Return Type\plain\fs20 
\par 
\par Logical
\par 
\par \b Remarks\plain\fs20 
\par 
\par If data of the specified format is currently contained in the Clipboard the function returns true (.T.). Otherwise, it will return false (.F.).
\par \pard 
\par \b Note\plain\fs20    
\par 
\par This function maps to the Windows API function \b IsClipboardFormatAvailable\plain\fs20 . For more information, see the Windows API documentation for this function.
\par 
\par \b See Also \plain\fs20 - \uldb CloseClip\plain\fs20 {\v LI4.7L}, \uldb CountClipF\plain\fs20 {\v 54EH_S9}. \uldb EmptyClip\plain\fs20 {\v 11NJOWG}, \uldb EnumClipFm\plain\fs20 {\v 12SSV0G}, \uldb GetClipDat\plain\fs20 {\v _708YP}, \uldb GetClipFmt\plain\fs20 {\v 3N0K8YJ}, \uldb OpenClip\plain\fs20 {\v 7XJE.L}, \uldb RegClipFmt\plain\fs20 {\v 1GPWPV0}, \uldb SetClipDat\plain\fs20 {\v LSILHM}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:006c}
{\up $}{\footnote\pard\plain{\up $} JustDrive}
{\up #}{\footnote\pard\plain{\up #} OPGGH3}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} JustDrive}
\b JustDrive( )
\par \pard \plain\fs20 
\par Returns the drive letter and colon from a filename or path.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b lcdrive = JustDrive(cFilename)
\par \plain\i\fs20 
\par \plain\f2\b\fs20 cFilename\plain\i\fs20 
\par \plain\fs20 
\par A character string specifying the complete path name or fully qualified filename for which you desire the drive letter.
\par 
\par \b Return Type\plain\fs20 
\par 
\par Character
\par \b 
\par Note
\par 
\par \plain\fs20 This function has been added to the language proper in version 6.0.
\par \b 
\par See Also\plain\fs20  -\uldb  AddBS\plain\fs20 {\v 14EGS1W}, \uldb CleanPath\plain\fs20 {\v C1HUI2}, \uldb DefaultExt\plain\fs20 {\v JCX88A}, \uldb DriveType\plain\fs20 {\v 074B7F}, \uldb ForceExt\plain\fs20 {\v 36PZ07N}, \uldb ForcePath\plain\fs20 {\v H1ZPGF}, \uldb JustExt\plain\fs20 {\v 2EALD5}, \uldb JustFName\plain\fs20 {\v 2QC._Z8}, \uldb JustPath\plain\fs20 {\v CQ2YEC}, \uldb JustStem\plain\fs20 {\v CQ6A6H}, \uldb MkDir\plain\fs20 {\v BHBSLF}, \uldb RmDir\plain\fs20 {\v BMDSLF}, \uldb ValidPath\plain\fs20 {\v 36PDQE}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:006d}
{\up $}{\footnote\pard\plain{\up $} JustExt}
{\up #}{\footnote\pard\plain{\up #} 2EALD5}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} JustExt}
\b JustExt( )
\par \pard \plain\fs20 
\par Returns the three-letter extension from a filename. This does not include the period.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b lcext = JustExt(cFilename)
\par \plain\i\fs20 
\par \plain\f2\b\fs20 cFilename\plain\i\fs20 
\par \plain\fs20 
\par A character string specifying the filename, which may or may not include the full path, of the file for which you want only the extension.
\par 
\par \b Return Type\plain\fs20 
\par 
\par Character
\par 
\par \b Note\plain\fs20 
\par 
\par This function has been added to the language proper in version 6.0.
\par 
\par \b See Also\plain\fs20  -\uldb  AddBS\plain\fs20 {\v 14EGS1W}, \uldb CleanPath\plain\fs20 {\v C1HUI2}, \uldb DefaultExt\plain\fs20 {\v JCX88A}, \uldb DriveType\plain\fs20 {\v 074B7F}, \uldb ForceExt\plain\fs20 {\v 36PZ07N}, \uldb ForcePath\plain\fs20 {\v H1ZPGF}, \uldb JustDrive\plain\fs20 {\v OPGGH3}, \uldb JustFName\plain\fs20 {\v 2QC._Z8}, \uldb JustPath\plain\fs20 {\v CQ2YEC}, \uldb JustStem\plain\fs20 {\v CQ6A6H}, \uldb MkDir\plain\fs20 {\v BHBSLF}, \uldb RmDir\plain\fs20 {\v BMDSLF}, \uldb ValidPath\plain\fs20 {\v 36PDQE}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:006e}
{\up $}{\footnote\pard\plain{\up $} JustFName}
{\up #}{\footnote\pard\plain{\up #} 2QC._Z8}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} JustFName}
\b JustFName( )
\par \pard \plain\fs20 
\par Returns the file name and its extension.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b lcfilename = JustFName(cFilename)
\par \plain\fs20 
\par \f2\b cFilename\plain\fs20 
\par 
\par A character string specifying the file name, which may or may not be fully qualified, of the file for which you want only the file name.
\par 
\par \b Return Type\plain\fs20 
\par 
\par Character
\par 
\par \b Example
\par 
\par \f2 lcfilename = \'93C:\'5cVFP\'5cVFP.EXE\'94
\par lcname = JustFName(lcfilename) && Returns \'93VFP.EXE\'94
\par \f11 
\par Notes\plain\fs20 
\par 
\par Calling \b JustFName()\plain\fs20  with a string which does not contain a filename returns an empty string.
\par \pard 
\par This function has been added to the language proper in version 6.0.
\par 
\par \b See Also\plain\fs20  -\uldb  AddBS\plain\fs20 {\v 14EGS1W}, \uldb CleanPath\plain\fs20 {\v C1HUI2}, \uldb DefaultExt\plain\fs20 {\v JCX88A}, \uldb DriveType\plain\fs20 {\v 074B7F}, \uldb ForceExt\plain\fs20 {\v 36PZ07N}, \uldb ForcePath\plain\fs20 {\v H1ZPGF}, \uldb JustDrive\plain\fs20 {\v OPGGH3}, \uldb JustExt\plain\fs20 {\v 2EALD5}, \uldb JustPath\plain\fs20 {\v CQ2YEC}, \uldb JustStem\plain\fs20 {\v CQ6A6H}, \uldb MkDir\plain\fs20 {\v BHBSLF}, \uldb RmDir\plain\fs20 {\v BMDSLF}, \uldb ValidPath\plain\fs20 {\v 36PDQE}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:006f}
{\up $}{\footnote\pard\plain{\up $} JustPpath}
{\up #}{\footnote\pard\plain{\up #} CQ2YEC}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} JustPath}
\b JustPath( )
\par \pard \plain\fs20 
\par Returns the path portion, excluding ending backslash, of a complete path and file name.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b lcpath = JustPath(cFilename)
\par \plain\i\fs20 
\par \plain\f2\b\fs20 cFilename\plain\fs20 
\par 
\par A character string specifying the fully qualified filename for which you want only the path.
\par 
\par \b Return Type\plain\fs20 
\par 
\par Character
\par 
\par \b Example\plain\fs20 
\par 
\par \f2\b lcpath = JustPath(\'93C:\'5cVFP50\'5cVFP.EXE\'94) && Returns \'93C:\'5cVFP50\'94
\par \plain\fs20 
\par \b Note\plain\fs20 
\par 
\par If the filename passed to the function does not contain a path, an empty string is returned.
\par \pard 
\par This function has been added to the language proper in version 6.0.
\par 
\par \b See Also\plain\fs20  -\uldb  AddBS\plain\fs20 {\v 14EGS1W}, \uldb CleanPath\plain\fs20 {\v C1HUI2}, \uldb DefaultExt\plain\fs20 {\v JCX88A}, \uldb DriveType\plain\fs20 {\v 074B7F}, \uldb ForceExt\plain\fs20 {\v 36PZ07N}, \uldb ForcePath\plain\fs20 {\v H1ZPGF}, \uldb JustDrive\plain\fs20 {\v OPGGH3}, \uldb JustExt\plain\fs20 {\v 2EALD5}, \uldb JustFName\plain\fs20 {\v 2QC._Z8}, \uldb JustStem\plain\fs20 {\v CQ6A6H}, \uldb MkDir\plain\fs20 {\v BHBSLF}, \uldb RmDir\plain\fs20 {\v BMDSLF}, \uldb ValidPath\plain\fs20 {\v 36PDQE}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0070}
{\up $}{\footnote\pard\plain{\up $} JustStem}
{\up #}{\footnote\pard\plain{\up #} CQ6A6H}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} JustStem}
\b JustStem( )
\par \pard \plain\fs20 
\par Returns the stem or primary file name (first eight characters or less preceding the period in the file name). The file name may or may not be fully qualified.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b lcstem = JustStem(cFilename)
\par 
\par cFilename
\par \plain\fs20 
\par A character string specifying the file name of the file for which you want only the stem.
\par 
\par \b Return Type\plain\fs20 
\par 
\par Character
\par 
\par \b Example\plain\fs20 
\par 
\par \b JustStem()\plain\fs20  is useful in determining the alias of a table prior to opening it. In the example below, the alias is extracted from the file name. If in use, the table\f251 \'92\f11 s work area is selected. If not in use, the table is opened.
\par \pard 
\par \f2\b * pctable is the fully qualified name of the table.
\par lcalias = JustStem(pctable)
\par IF NOT USED(lcalias)
\par   USE (pctable) IN 0 SHARED
\par ELSE
\par   SELECT (lcalias)
\par ENDIF
\par \plain\fs20 
\par \b Note\plain\fs20 
\par 
\par This function has been added to the language proper in version 6.0.
\par 
\par \b See Also\plain\fs20  -\uldb  AddBS\plain\fs20 {\v 14EGS1W}, \uldb CleanPath\plain\fs20 {\v C1HUI2}, \uldb DefaultExt\plain\fs20 {\v JCX88A}, \uldb DriveType\plain\fs20 {\v 074B7F}, \uldb ForceExt\plain\fs20 {\v 36PZ07N}, \uldb ForcePath\plain\fs20 {\v H1ZPGF}, \uldb JustDrive\plain\fs20 {\v OPGGH3}, \uldb JustExt\plain\fs20 {\v 2EALD5}, \uldb JustFName\plain\fs20 {\v 2QC._Z8}, \uldb JustPath\plain\fs20 {\v CQ2YEC}, \uldb MkDir\plain\fs20 {\v BHBSLF}, \uldb RmDir\plain\fs20 {\v BMDSLF}, \uldb ValidPath\plain\fs20 {\v 36PDQE}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0071}
{\up $}{\footnote\pard\plain{\up $} MainHwnd}
{\up #}{\footnote\pard\plain{\up #} 18_H6X8}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} MainHwnd}
\b MainhWnd( )
\par \pard \plain\fs20 
\par Returns the window handle of the main FoxPro window.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b lnhWnd = MainhWnd()
\par \plain\fs20 
\par \b Return Type\plain\fs20 
\par 
\par Numeric
\par 
\par \b Note\plain\fs20 
\par 
\par The window handle of the calling application is a common value required by many Windows API functions.
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0072}
{\up $}{\footnote\pard\plain{\up $} MkDir}
{\up #}{\footnote\pard\plain{\up #} BHBSLF}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} MkDir}
\b MkDir( )
\par \pard\tx355 \plain\fs20 
\par Creates a directory or folder.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b lnresult = MkDir(cPath)
\par 
\par cPath
\par \plain\fs20 
\par A character string specifying the directory/folder to create.
\par 
\par \b Return Type\plain\fs20 
\par 
\par Numeric
\par 
\par \b Remarks\plain\fs20 
\par 
\par This function does not check for a valid length or name of a directory string. The return values are:
\par 
\par 0\tab The directory/folder was successfully created.
\par 1\tab The function could not create the directory/folder.
\par 6\tab The directory/folder with the specified name already exists.
\par \pard\tx355 
\par This function is only available in FoxTools version 1.01 or later. This function has also been made obsolete by the presence of the \b MD/MKDIR\plain\fs20  function in Visual FoxPro.
\par 
\par \b See Also\plain\fs20  -\uldb  AddBS\plain\fs20 {\v 14EGS1W}, \uldb CleanPath\plain\fs20 {\v C1HUI2}, \uldb DefaultExt\plain\fs20 {\v JCX88A}, \uldb DriveType\plain\fs20 {\v 074B7F}, \uldb ForceExt\plain\fs20 {\v 36PZ07N}, \uldb ForcePath\plain\fs20 {\v H1ZPGF}, \uldb JustDrive\plain\fs20 {\v OPGGH3}, \uldb JustExt\plain\fs20 {\v 2EALD5}, \uldb JustFName\plain\fs20 {\v 2QC._Z8}, \uldb JustPath\plain\fs20 {\v CQ2YEC}, \uldb JustStem\plain\fs20 {\v CQ6A6H}, \uldb RmDir\plain\fs20 {\v BMDSLF}, \uldb ValidPath\plain\fs20 {\v 36PDQE}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0073}
{\up $}{\footnote\pard\plain{\up $} MsgBox}
{\up #}{\footnote\pard\plain{\up #} 1I9WPUK}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} MsgBox}
\b MsgBox(\'a0)
\par \pard \plain\fs20 
\par Displays a modal dialog box with a message, centered in the screen and returns the user\f251 \'92\f11 s response to the message.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b lnresponse = MsgBox(cText, cTitle, nType)
\par \plain\i\fs20 
\par \plain\f2\b\fs20 cText
\par \plain\fs20 
\par Specifies the contents of the message that appears in the dialog.
\par 
\par \f2\b ctitle
\par \plain\fs20 
\par Specifies the title to appear on the dialog box.
\par 
\par \f2\b ntype
\par \plain\fs20 
\par Specifies the type of command button configuration and icon appearing in the dialog box. Values passed are a combination of one or more of the following:
\par \pard\tx355 
\par \b Button Types\plain\fs20 
\par 
\par \b nType\tab \tab Type\tab \tab \tab \tab Description
\par \plain\fs20 0\tab \tab MB_OK\tab \tab \tab \tab Ok command button
\par 1\tab \tab MB_OKCANCEL\tab \tab Ok and Cancel command buttons
\par 2\tab \tab MB_ABORTRETRYIGNORE\tab Abort, Retry, and Ignore command buttons
\par 3\tab \tab MB_YESNOCANCEL\tab \tab Yes, No, and Cancel command buttons. 
\par 4\tab \tab MB_YESNO\tab \tab \tab Yes and No command buttons
\par 5\tab \tab MB_RETRYCANCEL\tab \tab Retry and Cancel command buttons
\par 
\par \b Icon Types
\par \plain\fs20 
\par 16\tab \tab MB_ICONSTOP\tab \tab Stop sign icon
\par 32\tab \tab MB_ICONQUESTION\tab \tab Question mark icon
\par \pard\tx355 48\tab \tab MB_ICONEXCLAMATION\tab Exclamation point icon
\par 64\tab \tab MB_ICONINFORMATION\tab Information icon
\par 
\par \b Default Button\plain\fs20 
\par 
\par 0\tab \tab MB_DEFBUTTON1\tab \tab The first button is the default
\par 256\tab \tab MB_DEFBUTTON2\tab \tab The second button is the default
\par 512\tab \tab MB_DEFBUTTON3\tab \tab The third button is the default
\par 
\par \b Modality Level\plain\fs20 
\par 
\par 0\tab \tab \tab MB_APPLMODAL\tab \tab Modality is confined to the application
\par 65536\tab \tab MB_SYSTEMMODAL\tab \tab Modality is system wide
\par 131072\tab \tab MB_TASKMODAL\tab \tab Modality is to the current task
\par \pard\tx355 
\par \b Return Type\plain\fs20 
\par 
\par Numeric
\par 
\par \b Remarks\plain\fs20 
\par 
\par \b MsgBox( )\plain\fs20  returns a value indicating which of the buttons the user selected
\par 
\par \b Return value\tab ID of button clicked\tab Description\plain\fs20 
\par 1\tab \tab idok\tab \tab \tab OK command button
\par 2\tab \tab idcancel\tab \tab Cancel command button
\par 3\tab \tab idabort\tab \tab \tab Abort command button
\par 4\tab \tab idretry\tab \tab \tab Retry command button
\par 5\tab \tab idignore\tab \tab Ignore command button
\par 6\tab \tab idyes\tab \tab \tab Yes command button
\par 7\tab \tab idno\tab \tab \tab No command button
\par 
\par \b Notes\plain\fs20 
\par \pard\tx355 
\par In VFP this function is obsolete, having been replaced by the \b MESSAGEBOX( )\plain\fs20  function. Note that it takes the same values as described above. All of these are not documented in the VFP help file. This function maps directly to the Windows API function \b MessageBox()\plain\fs20 . When trying to control the modality level, the developer should not make assumptions about the availability of other applications based on the description. Tests should be conducted to determine their meanings.
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0074}
{\up $}{\footnote\pard\plain{\up $} NextWord}
{\up #}{\footnote\pard\plain{\up #} _64OBQ}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} NextWord}
\b NextWord( )
\par \pard \plain\fs20 
\par \b NextWord()\plain\fs20  is the FOXTOOLS equivalent of the AT() function. It returns the characters between a supplied character index and the next word delimiter or the end of the string. Since it has a default delimiter, in many instances it can be used to parse text returned from a DDE request (CF_TEXT), or other delimited format.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b lcresult = NextWord(cString, nPosition[, cDelimiter])
\par \plain\fs20 
\par \f2\b cString
\par \plain\fs20 
\par The string to search.
\par 
\par \f2\b nPosition\plain\fs20 
\par \pard 
\par The position to begin searching from.
\par 
\par \f2\b cdelimiter
\par \plain\fs20 
\par The optional delimiter(s). The function returns a character string starting at this point and ending at the first occurrence of a character contained in this string. According to the official FOXTOOLS documentation, If not supplied, the default delimiters are: spaces, tabs, and carriage returns (CHR(13)). However, in testing, using versions of the example below, if the delimiter was not supplied, the only characters that worked were the space (CHR(32)), tab (CHR(9)), and the line feed (CHR(10)). The carriage return, failed to run properly.
\par \pard 
\par Unlike the AT() function, \b Nextword()\plain\fs20  will evaluate each of the characters contained in cDelimiter and the returned character string will terminate at the character immediately preceding the first located delimiter.
\par 
\par \b Return Type\plain\fs20 
\par 
\par Character
\par 
\par \b Remarks
\par \plain\fs20 
\par Through version 6.0 of the library, the maximum number of characters that \b NextWord()\plain\fs20  will return is 255. Words longer than is are truncated to 255 characters.
\par 
\par 
\par \b Example\plain\fs20 
\par 
\par The following uses \b NextWord()\plain\fs20  to parse a CF_TEXT delimited string. lcstring is the string being parsed.
\par \pard 
\par \f2\b lnindex = 1
\par lccftext = CHR(13) + CHR(10)
\par lcstring = \f251 \'91\f2 one\f251 \'92\f2  + lccftext + \f251 \'91\f2 two\f251 \'92\f2  +;
\par  lccftext + \f251 \'91\f2 three\f251 \'92\f2  + lccftext + \f251 \'91\f2 four\f251 \'92\f2 
\par lnstrlen = LEN(lcstring)
\par DO WHILE lnindex < lnstrlen
\par   lcresult = NextWord(lcstring, lnindex)
\par   ? lcresult
\par   lnindex = lnindex + LEN(lcresult) + 1
\par ENDDO
\par \plain\fs20 
\par \b See Also\plain\fs20  - \uldb Reduce\plain\fs20 {\v 1MVU8I8}, \uldb StrFilter\plain\fs20 {\v 1E2V3OK}, \uldb WordNum\plain\fs20 {\v 4PUMZUE}, \uldb Words\plain\fs20 {\v BRG6GG}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0075}
{\up $}{\footnote\pard\plain{\up $} OpenClip}
{\up #}{\footnote\pard\plain{\up #} 7XJE.L}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} OpenClip}
\b OpenClip( )
\par \pard \plain\fs20 
\par Opens the clipboard for use by functions related to it.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b llresult = OpenClip(nHandle)
\par \plain\fs20 
\par \f2\b nHandle
\par \plain\fs20 
\par The handle of the window to be associated with the clipboard. See \uldb \b _WFindTitle()\plain\b\fs20 {\v CM7U01}\plain\fs20  and \uldb \b _WhTohWnd()\plain\b\fs20 {\v 20RGYZ_}\plain\fs20  for information regarding how to obtain the window handle for a given form. Zero, however, is acceptable. To retrieve handle of the FoxPro main window, use \uldb \b MainhWnd()\plain\b\fs20 {\v 18_H6X8}\plain\fs20 .
\par 
\par \b Return Type\plain\fs20 
\par 
\par Logical
\par \pard 
\par \b Remarks\plain\fs20 
\par 
\par If the function succeeds in opening Clipboard, the return value is .T., otherwise .F.. Most Clipboard functions rely on opening the Clipboard prior to calling the function. _CLIPTEXT can be used to store and retrieve the contents of the Windows Clipboard.  The format of the _CLIPTEXT variable, however, is limited to text.
\par 
\par If you are successful in opening the Clipboard, you should be sure to close it with \uldb \b CloseClip\plain\b\fs20 {\v LI4.7L}\plain\fs20 . If you fail to do so, the Clipboard will not be available for use by other applications.
\par \pard 
\par \b Note\plain\fs20    
\par 
\par This function maps to the Windows API function \b OpenClipboard\plain\fs20 . For more information, see the Windows API documentation for this function.
\par 
\par \b See Also \plain\fs20 - \uldb CloseClip\plain\fs20 {\v LI4.7L}, \uldb CountClipF\plain\fs20 {\v 54EH_S9}. \uldb EmptyClip\plain\fs20 {\v 11NJOWG}, \uldb EnumClipFm\plain\fs20 {\v 12SSV0G}, \uldb GetClipDat\plain\fs20 {\v _708YP}, \uldb GetClipFmt\plain\fs20 {\v 3N0K8YJ}, \uldb IsClipFmt\plain\fs20 {\v 1HSGYXC}, \uldb RegClipFmt\plain\fs20 {\v 1GPWPV0}, \uldb SetClipDat\plain\fs20 {\v LSILHM}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0076}
{\up $}{\footnote\pard\plain{\up $} PutProStrg}
{\up #}{\footnote\pard\plain{\up #} XDITBE}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} PutProStrg}
\b PutProStrg( )
\par \pard \plain\fs20 
\par Inserts a string in the specified section of the Windows initialization file, WIN.INI.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b lnresult = PutProStrg(cSection, cEntry, cString)
\par \plain\fs20 
\par \f2\b cSection
\par \plain\fs20 
\par The string that indicating the section to which the string is to be inserted. If the section indicated does not exist it is created . The section name is not case dependent.
\par 
\par \f2\b cEntry\plain\fs20 
\par 
\par A character string indicating the entry (indicated by being to the left of the equal sign) where the value is to be inserted. If the entry is NULL (0), the entire section, including the section entry are deleted..
\par \pard 
\par \f2\b cString\plain\fs20 
\par 
\par The character string to be written. Passing a zero (NULL) will delete the entry indicated by the cEntry parameter.
\par 
\par \b Return Type\plain\fs20 
\par 
\par Logical
\par 
\par \b Remarks\plain\fs20 
\par 
\par This function is not available in the versions of FOXTOOLS that shipped with FoxPro for Windows 2.x.
\par 
\par The official documentation shows the return type as being numeric. Testing shows the return type to be logical. If the section is written, or deleted, the return value is .T. If the function cannot write the entry, the return value is .F.
\par \pard 
\par The official documentation refers to each of these parameters as \'93pointers to\'94. However, it also does not indicate that the values should be passed by reference. Testing shows that they may be passed by value.
\par 
\par This function maps directly to the Windows API function \b WriteProfileString\plain\fs20 .
\par 
\par \b See Also\plain\fs20  - \uldb GetProStrg\plain\fs20 {\v 19B.QHP}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0077}
{\up $}{\footnote\pard\plain{\up $} Reduce}
{\up #}{\footnote\pard\plain{\up #} 1MVU8I8}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} Reduce}
\b Reduce( )
\par \pard \plain\fs20 
\par Replaces specified characters in a string with a space and removes additional occurrences.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b lcresult = Reduce(cSearch, cReplace)
\par \plain\fs20 
\par \f2\b cSearch
\par \plain\fs20 
\par The character string to modify.
\par 
\par \f2\b cReplace
\par \plain\fs20 
\par The characters to search for and replaces with a space. If multiple characters are specified, each is treated separately. In other words, they are not treated as a multi-character string, and the function does not look for sequential occurrences of them.
\par \pard 
\par \b Return Type\plain\fs20 
\par 
\par Character
\par 
\par \b Remarks\plain\fs20 
\par 
\par The character string returned by the function removes both leading and repeated spaces with the string. It may be used for replacing a group of spaces with a single space (as shown in the example), or delimiters such as tables or carriage returns.
\par 
\par \b Example
\par \plain\fs20 
\par \f2\b lcname = \'93John     Smith\'94 && Five spaces between John and Smith
\par lcname = Reduce(lcname, SPACE(1)) && Removes four of the five
\par \plain\fs20 
\par \b See Also\plain\fs20  - \uldb NextWord\plain\fs20 {\v _64OBQ}, \uldb StrFilter\plain\fs20 {\v 1E2V3OK}, \uldb WordNum\plain\fs20 {\v 4PUMZUE}, \uldb Words\plain\fs20 {\v BRG6GG}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0078}
{\up $}{\footnote\pard\plain{\up $} RegClipFmt}
{\up #}{\footnote\pard\plain{\up #} 1GPWPV0}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} RegClipFmt}
\b RegClipFmt( )
\par \pard \plain\fs20 
\par Registers a new, user defined Clipboard format.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b lnformat = RegClipFmt(cFormat)
\par \plain\fs20 
\par \f2\b cFormat\plain\fs20 
\par 
\par A character string naming the new format.
\par 
\par \b Return Type\plain\fs20 
\par 
\par Numeric
\par 
\par \b Remarks\plain\fs20 
\par 
\par Once the format is registered, it can then be used in subsequent clipboard functions as a valid format in which to store data on the Clipboard, and it will appear in the list of available formats.
\par 
\par The return value is the value used to determine if the newly registered format exists on the clipboard or in enumerating the registered types.  If the identical format name has been registered before, even by a different application, the format's reference count is incremented (increased by one) and the same value is returned as when the format was originally registered. If the return value is zero, the format cannot be registered.
\par \pard 
\par Almost all Clip functions rely on opening the Clipboard before using the function. _CLIPTEXT can be used to store and retrieve the contents of the Windows Clipboard.  The format of the _CLIPTEXT variable, however, is limited to text.
\par 
\par \b Note\plain\fs20    
\par 
\par This function maps to the Windows API function \b RegisterClipboardFormat\plain\fs20 . For more information, see the Windows API documentation for this function.
\par 
\par \b See Also \plain\fs20 - \uldb CloseClip\plain\fs20 {\v LI4.7L}, \uldb CountClipF\plain\fs20 {\v 54EH_S9}. \uldb EmptyClip\plain\fs20 {\v 11NJOWG}, \uldb EnumClipFm\plain\fs20 {\v 12SSV0G}, \uldb GetClipDat\plain\fs20 {\v _708YP}, \uldb GetClipFmt\plain\fs20 {\v 3N0K8YJ}, \uldb IsClipFmt\plain\fs20 {\v 1HSGYXC}, \uldb OpenClip\plain\fs20 {\v 7XJE.L}, \uldb SetClipDat\plain\fs20 {\v LSILHM}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0079}
{\up $}{\footnote\pard\plain{\up $} RegFN}
{\up #}{\footnote\pard\plain{\up #} BM.VIB}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} DLL;RegFN;RegFN32}
\b RegFN( )/RegFN32( )
\par \pard\tx355 \plain\fs20 
\par Registers a call to a dynamic link library (DLL) and returns a reference handle to access calls to the library.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b lnhandle = RegFN(cFuncName, cParmList, cRetVal[, cDLLFile])
\par \plain\fs20 
\par \f2\b lnhandle = RegFN32(cFuncName, cParmList, cRetVal[, cDLLFile])
\par \plain\fs20 
\par \f2\b cFuncName\plain\fs20 
\par 
\par The function name in the library being registered.
\par 
\par \f2\b cParmList
\par \plain\fs20 
\par The a string of characters describing the parameter list. The following values are used:
\par 
\par \b Value\plain\fs20 \tab \tab \tab \b Description\plain\fs20 
\par \pard\tx355 
\par C\tab \tab \tab Character string.
\par D\tab \tab \tab Double precision floating point number.
\par F\tab \tab \tab Floating point number.
\par I\tab \tab \tab 32 bit integer.
\par L\tab \tab \tab Long integer (32 bits).
\par S\tab \tab \tab Short integer (16 bits).
\par 
\par Arguments are passed by value to functions unless otherwise specified. To declare an argument being passed by reference, precede it with @.
\par 
\par \f2\b cRetVal\plain\i\fs20 
\par \plain\fs20 
\par The value being returned by the function. This must be on of the values listed in the table above.
\par 
\par \f2\b cDLLFile\plain\fs20 
\par \pard\tx355 
\par The file name of the DLL containing the function. This is optional if  the function is part of the Windows 3.1 (User.exe, Krnl386.exe, or Gdi.exe) or Windows 95 (Kernel32.dll, Gdi32.dll, User32.dll, Advapi32.dll, or Mpr.dll) APIs.
\par 
\par \b Remarks\plain\fs20 
\par 
\par RegFN32 is not available in the versions of FOXTOOLS that shipped with FoxPro for Windows 2.x.
\par 
\par If the function is successfully registered the value will be greater than or equal to 0. A negative value indicates that an error occurred. After a successful registration, the return value is then used to call the function via CallFN. RegFN32 always makes calls to the 32 bit functions. RegFN calls are platform dependent. Under 16 bit Windows, the calls are to the 16 bit functions. Under Win32, the 32 bit functions.
\par \pard\tx355 
\par \b See Also\plain\fs20  - \uldb  CallFN\plain\fs20 {\v 211_Z8Q}
\par 
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:007a}
{\up $}{\footnote\pard\plain{\up $} RGBComp}
{\up #}{\footnote\pard\plain{\up #} WX9ZQ_}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} RGBComp}
\b RGBComp( )
\par \pard \plain\fs20 
\par Returns the individual red, green, and blue components of a RGB color value.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b llresult = RGBComp(nRGBColor, @nRedVal, @nGreenVal, @nBlueVal)
\par \plain\fs20 
\par \f2\b nRGBColor\plain\fs20 
\par 
\par Specifies a RGB color value ranging from 0 to 16777215. For example, the default RGB value of the default background color of a form is 12632256.
\par 
\par \f2\b @nRedVal\plain\fs20 
\par 
\par The variable to store the red color value in from nRGBColor.
\par 
\par \f2\b @nGreenVal\plain\fs20 
\par 
\par The variable to store the green color value in from nRGBColor.
\par \pard 
\par \f2\b @nBlueVal\plain\fs20 
\par 
\par The variable to store the blue color value in from nRGBColor.
\par 
\par \b Return Type\plain\fs20 
\par 
\par Logical
\par 
\par \b Remarks\plain\fs20 
\par 
\par This function is not available in the versions of FOXTOOLS that shipped with FoxPro for Windows 2.x.
\par 
\par The function will always return .T. even if the value is beyond the range of acceptable color values. A data type mismatch will occur if the variables to hold the values are not passed by reference.
\par 
\par Individual components range in value from 0 to 255. To obtain the composite color individual values use the FoxPro \b RGB()\plain\fs20  function.
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:007b}
{\up $}{\footnote\pard\plain{\up $} RmDir}
{\up #}{\footnote\pard\plain{\up #} BMDSLF}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} RmDir}
\b RmDir( )
\par \pard \plain\fs20 
\par Deletes a directory of folder.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b lnresult = RmDir(cPath)
\par \plain\fs20 
\par \f2\b cPath
\par \plain\fs20 
\par The path name of the directory or folder to be removed.
\par 
\par \b Return Type\plain\fs20 
\par 
\par Numeric
\par 
\par \b Remarks\plain\fs20 
\par 
\par This function is only available in FoxTools version 1.01 or later.
\par 
\par Returns 0 if successful and 1 if not successful. This function has also been made obsolete by the presence of the \b RD/RMDIR\plain\fs20  function in Visual FoxPro.
\par 
\par \b See Also\plain\fs20  -\uldb  AddBS\plain\fs20 {\v 14EGS1W}, \uldb CleanPath\plain\fs20 {\v C1HUI2}, \uldb DefaultExt\plain\fs20 {\v JCX88A}, \uldb DriveType\plain\fs20 {\v 074B7F}, \uldb ForceExt\plain\fs20 {\v 36PZ07N}, \uldb ForcePath\plain\fs20 {\v H1ZPGF}, \uldb JustDrive\plain\fs20 {\v OPGGH3}, \uldb JustExt\plain\fs20 {\v 2EALD5}, \uldb JustFName\plain\fs20 {\v 2QC._Z8}, \uldb JustPath\plain\fs20 {\v CQ2YEC}, \uldb JustStem\plain\fs20 {\v CQ6A6H}, \uldb MkDir\plain\fs20 {\v BHBSLF}, \uldb ValidPath\plain\fs20 {\v 36PDQE}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:007c}
{\up $}{\footnote\pard\plain{\up $} SetClipDat}
{\up #}{\footnote\pard\plain{\up #} LSILHM}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} SetClipDat}
\b SetClipDat( )
\par \pard\tx355 \plain\fs20 
\par Sets the data type on the opened Clipboard. This data type may be an application defined type.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b llresult = SetClipDat(nFormat, cData)
\par \plain\fs20 
\par \f2\b nFormat
\par \plain\fs20 
\par Specifies an identifier for possible Clipboard formats. The predefined types are shown in the table below.
\par 
\par \b nFormat\tab Description (define type)\plain\fs20 
\par 1\tab \tab \tab cf_Text
\par 2\tab \tab \tab cf_Bitmap
\par 3\tab \tab \tab cf_MetaFilePict
\par 4\tab \tab \tab cf_SYLK
\par 5\tab \tab \tab cf_DIF
\par 6\tab \tab \tab cf_TIFF
\par 7\tab \tab \tab cf_OEMText
\par 8\tab \tab \tab cf_DIB
\par \pard\tx355 9\tab \tab \tab cf_Palette
\par 
\par \f2\b cData\f11 
\par \plain\fs20 
\par A character string specifying the data to place on the Clipboard.
\par 
\par \b Return Type\plain\fs20 
\par 
\par Logical
\par 
\par \b Remarks\plain\fs20 
\par 
\par You must first open the Clipboard using \uldb \b OpenClip\plain\b\fs20 {\v 7XJE.L}\plain\fs20  before calling the function. If the Clipboard Viewer is open, its window does not update to display the data placed in it by this function until after the call to \uldb \b CloseClip\plain\b\fs20 {\v LI4.7L}\plain\fs20 .
\par 
\par \b Note\plain\fs20    
\par 
\par This function maps to the Windows API function \b SetClipboardData\plain\fs20 . For more information, see the Windows API documentation for this function.
\par \pard\tx355 
\par \b Example\plain\fs20 
\par 
\par \f2\b * Get the VFP main window handle
\par lnhWnd = MainhWnd()
\par * Open the Clipboard
\par IF OpenClip(lnhWnd)
\par   * Create a user defined format
\par   cformat = 'cfFoo'
\par   * Register it and get the handle for future use.
\par   lnformat = RegClipFmt(cFormat)
\par   * User defined data to place on the clipboard.
\par   lcfoo = 'Foobar'
\par   * Returns .T. if the data is placed on the Clipboard.
\par   llresult = SetClipDat(lnFormat, lcfoo)
\par   * Release the Clipboard.
\par   llresult = CloseClip() 
\par \pard\tx355 ENDIF
\par \plain\fs20 
\par \b See Also \plain\fs20 - \uldb CloseClip\plain\fs20 {\v LI4.7L}, \uldb CountClipF\plain\fs20 {\v 54EH_S9}. \uldb EmptyClip\plain\fs20 {\v 11NJOWG}, \uldb EnumClipFm\plain\fs20 {\v 12SSV0G}, \uldb GetClipDat\plain\fs20 {\v _708YP}, \uldb GetClipFmt\plain\fs20 {\v 3N0K8YJ}, \uldb IsClipFmt\plain\fs20 {\v 1HSGYXC}, \uldb OpenClip\plain\fs20 {\v 7XJE.L}, \uldb RegClipFmt\plain\fs20 {\v 1GPWPV0}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:007d}
{\up $}{\footnote\pard\plain{\up $} StrFilter}
\pard\keepn\sb235\sa55 {\up #}{\footnote\pard\plain{\up #} 1E2V3OK}
{\up K}{\footnote\pard\plain{\up K} StrFilter}
\b StrFilter( )
\par \pard \plain\fs20 
\par Removes characters from a string excepting those indicated. The function is case sensitive.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b lcresult = StrFilter(cString, cSearch)
\par 
\par cString
\par \plain\fs20 
\par The character string to be searched.
\par 
\par \f2\b cSearch
\par \plain\fs20 
\par Character string specifying those characters not to be removed from cString.
\par 
\par \b Return Type\plain\fs20 
\par 
\par Character
\par 
\par \b Remarks\plain\fs20 
\par 
\par The string returned by the function will contain only the occurrences of those characters that are contained in the search string.
\par \pard 
\par \b Example\plain\fs20 
\par 
\par While the application of the function may have limited usage, it can be used to greatly simplify and speed up solutions to some problems. As an example, the following code demonstrates how to the function could be used to count the number of vowels in a defined section of text (a large memo field, for example).
\par 
\par \f2\b * lctext is a character string containing an unknown number of vowels
\par * Define the upper case vowels
\par lcvowels = \f251 \'91\f2 AEIOUY\f251 \'92\f2 
\par \pard * Add the lower case ones
\par lcvowels = lcvowls + LOWER(lcvowels)
\par * Get only the vowels
\par lctxtvowels = StrFilter(lctext, lcvowels)
\par * Show the result
\par ? \'93Total vowels\'94 + LEN(lctxtvowels)
\par * Show how many of each
\par lnvowellen = LEN(lcvowels)
\par FOR lni = 1 TO lnvowellen
\par   lconevowel = SUBSTR(lcvowels, lni, 1)
\par   lchars = StrFilter(lctxtvowels, lconevowel)
\par   ? \'93Total \'93 + lconevowel + LEN(lchars)
\par NEXT
\par \plain\fs20 
\par \b See Also\plain\fs20  - \uldb NextWord\plain\fs20 {\v _64OBQ}, \uldb Reduce\plain\fs20 {\v 1MVU8I8}, \uldb WordNum\plain\fs20 {\v 4PUMZUE}, \uldb Words\plain\fs20 {\v BRG6GG}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:007e}
{\up $}{\footnote\pard\plain{\up $} ValidPath}
{\up #}{\footnote\pard\plain{\up #} 36PDQE}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} ValidPath}
\b ValidPath( )
\par \pard \plain\fs20 
\par Checks the validity of an MS-DOS file name or path.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b llvalid = ValidPath(cFileName)
\par \plain\i\fs20 
\par \plain\f2\b\fs20 cFileName\plain\fs20 
\par 
\par Specifies the path or file name to be checked.
\par 
\par \b Return Type\plain\fs20 
\par 
\par Logical
\par 
\par \b Remarks\plain\fs20 
\par 
\par \b ValidPath()\plain\fs20  checks that a file or path name is syntactically legal. It does not check for the existence of the specified file or path. The function is not 100% accurate and can interpret a file or path as being valid when it is actually invalid. However, it will not reject a valid name. Note that the function will not work correctly with long file names.
\par \pard 
\par \b See Also\plain\fs20  -\uldb  AddBS\plain\fs20 {\v 14EGS1W}, \uldb CleanPath\plain\fs20 {\v C1HUI2}, \uldb DefaultExt\plain\fs20 {\v JCX88A}, \uldb DriveType\plain\fs20 {\v 074B7F}, \uldb ForceExt\plain\fs20 {\v 36PZ07N}, \uldb ForcePath\plain\fs20 {\v H1ZPGF}, \uldb JustDrive\plain\fs20 {\v OPGGH3}, \uldb JustExt\plain\fs20 {\v 2EALD5}, \uldb JustFName\plain\fs20 {\v 2QC._Z8}, \uldb JustPath\plain\fs20 {\v CQ2YEC}, \uldb JustStem\plain\fs20 {\v CQ6A6H}, \uldb MkDir\plain\fs20 {\v BHBSLF}, \uldb RmDir\plain\fs20 {\v BMDSLF}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:007f}
{\up $}{\footnote\pard\plain{\up $} WordNum}
{\up #}{\footnote\pard\plain{\up #} 4PUMZUE}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} WordNum}
\b WordNum( )
\par \pard \plain\fs20 
\par Returns the specified word number within a string.
\par 
\par \b Syntax\plain\fs20 
\par 
\par \f2\b lcword = WordNum(cString, nIndex[, cDelimiter])
\par 
\par cString
\par \plain\fs20 
\par A character string containing the word to be returned.
\par 
\par \f2\b nIndex\plain\fs20 
\par 
\par Specifies the word number within the search string to be returned. If nIndex is 3, \b WordNum( )\plain\fs20  returns the third word provided that cString contains at least three words.
\par 
\par \f2\b cDelimiter\plain\fs20 
\par 
\par By default WordNum() uses the space, tab and line feed (CHR(10)) to specify the character used to delimit the words in cString. If the characters used to delimit word does not separate each word (punctuation marks for example), they should be included along with these characters. The example below demonstrates this technique.
\par \pard 
\par Note that the FOXTOOLS.HLP file indicates that a carriage return (CHR(13)) rather than a line feed is one of the default delimiters. Tests, however, indicate otherwise.
\par 
\par \b Return Type\plain\fs20 
\par 
\par Character
\par 
\par \b Remarks\plain\fs20 
\par 
\par If cString contains fewer words than the number specified with cIndex, \b WordNum( )\plain\fs20  returns an empty string.
\par 
\par Through version 6.0 of the library, the maximum number of characters that \b WordNum( )\plain\fs20  will return is 255. Words longer than is are truncated to 255 characters.
\par \pard 
\par \b Example\plain\fs20 
\par 
\par \f2\b lctext = 'This is a demonstration of using the function WordNum().' +;
\par   'This is a second sentence.'
\par lcword = WordNum(lctext, 5) && Returns \'93of\'94
\par * Adding the period as a delimeter as well as the space.
\par lcword = WordNum(lctext, 9, SPACE(1) + '.') && Returns \'93WordNum()\'94
\par \plain\fs20 
\par \b See Also\plain\fs20  - \uldb NextWord\plain\fs20 {\v _64OBQ}, \uldb Reduce\plain\fs20 {\v 1MVU8I8}, \uldb StrFilter\plain\fs20 {\v 1E2V3OK}, \uldb Words\plain\fs20 {\v BRG6GG}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0080}
{\up $}{\footnote\pard\plain{\up $} Words}
{\up #}{\footnote\pard\plain{\up #} BRG6GG}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} Words}
\b Words(\'a0)
\par \pard \plain\fs20 
\par Returns the number of words in a string.
\par 
\par \b Syntax\plain\fs20 
\par 
\par 
\par \f2\b lnwords = Words(cString[, cDelimiter])
\par \plain\fs20 
\par \f2\b cString
\par \plain\fs20 
\par The character string containing the words to be counted.
\par 
\par \f2\b cDelimiter
\par \plain\fs20 
\par Specifies the character used to delimit words in cString. The default delimiters are space, tab, and line feed (CHR(10)). If additional delimiters are required, these default characters should be included in the value of cDelimiter.
\par 
\par \b Return Type\plain\fs20 
\par 
\par Numeric
\par \pard 
\par \b See Also\plain\fs20  - \uldb NextWord\plain\fs20 {\v _64OBQ}, \uldb Reduce\plain\fs20 {\v 1MVU8I8}, \uldb StrFilter\plain\fs20 {\v 1E2V3OK}, \uldb WordNum\plain\fs20 {\v 4PUMZUE}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0081}
{\up $}{\footnote\pard\plain{\up $} Language}
{\up #}{\footnote\pard\plain{\up #} BG5ZD.}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} New}
\b Foxtools Functions Added To Version 6.0
\par \pard \plain\fs20 
\par According to the help file accompanying the beta version of VFP 6.0, the following functions from the Foxtools library have been added as part of the language. These functions have been removed from the library in version 6.0.
\par 
\par \uldb AddBS\plain\fs20 {\v 14EGS1W}
\par \uldb GetFileVersion\plain\fs20 {\v IP6OP8}
\par \uldb DefaultExt\plain\fs20 {\v JCX88A}
\par \uldb DriveType\plain\fs20 {\v 074B7F}
\par \uldb ForceExt\plain\fs20 {\v 36PZ07N}
\par \uldb ForcePath\plain\fs20 {\v H1ZPGF}
\par \uldb JustDrive\plain\fs20 {\v OPGGH3}
\par \uldb JustExt\plain\fs20 {\v 2EALD5}
\par \uldb JustFName\plain\fs20 {\v 2QC._Z8}
\par \uldb JustPath\plain\fs20 {\v CQ2YEC}
\par \uldb JustStem\plain\fs20 {\v CQ6A6H}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0082}
{\up $}{\footnote\pard\plain{\up $} New}
{\up #}{\footnote\pard\plain{\up #} .EN3EU}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} New Functions}
\b New Functions In Foxtools 6.0
\par \pard \plain\fs20 The following functions were introduced in the version of the library that ships with Visual FoxPro 6.0. According to the article, \i Custom OLE Servers\plain\fs20  by Calvin Hsia, the purpose of these functions is to resolve the host name for Web based applications. This document is available in the MSDN Library. As of this writing, this document is available on-line at: \ul\cf1 http://msdn.microsoft.com/library/backgrnd/html/msdn_custole.htm\plain\fs20 .
\par 
\par Note that _WSockStartUp should be called prior to trying to resolve the host and _WSockCleanUp should be call when the host has been resolved.
\par \pard 
\par \uldb _WSockCleanup\plain\fs20 {\v ZP_OWE}
\par \uldb _WSockGetHostByAddr\plain\fs20 {\v 3IFT2Z}
\par \uldb _WSockStartUp\plain\fs20 {\v I11393}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0083}
{\up $}{\footnote\pard\plain{\up $} Cleanup}
{\up #}{\footnote\pard\plain{\up #} ZP_OWE}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} Cleanup;Winsock}
\b _WSockCleanUp( )\fs24 
\par \pard \plain\fs20 Uninitializes the Winsock library.
\par 
\par \b Syntax
\par \plain\fs20 
\par \f2\b lnresult = _WSockCleanUp()
\par \plain\fs20 
\par \b Return Type
\par \plain\fs20 
\par Numeric
\par 
\par \b Remarks
\par \plain\fs20 
\par Call _WSockCleanup() to uninitialize the Winsock library after calls to _WSockStartUp() and/or _WSockGetHostByAddr(). Always returns zero.
\par 
\par \b See Also\plain\fs20  \uldb _WSockGetHostByAddr\plain\fs20 {\v 3IFT2Z}, \uldb _WSockStartUp\plain\fs20 {\v I11393}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0084}
{\up $}{\footnote\pard\plain{\up $} Host}
{\up #}{\footnote\pard\plain{\up #} 3IFT2Z}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} Address;Host;IP Address}
\b _WSockGetHostByAddr( )\fs24 
\par \pard \plain\fs20 Resolves the host computer name from the IP address.
\par 
\par \b Syntax
\par \plain\fs20 
\par \f2\b lnresult = _WSockGetHostByAddr(lcIPAddr, @lcbuffer)
\par 
\par lcIPAddr
\par \plain\fs20 
\par The IP Address of the host computer to be resolved.
\par 
\par \f2\b @lcbuffer
\par \plain\fs20 
\par A buffer for the host computer name.
\par 
\par \b Return Type
\par \plain\fs20 
\par Numeric
\par 
\par \b Remarks
\par \plain\fs20 
\par The function will return 1 if it is able to resolve the name of the host computer. If it cannot, 0 is returned.
\par 
\par See Also - \uldb _WSockCleanup\plain\fs20 {\v ZP_OWE}, \uldb _WSockStartUp\plain\fs20 {\v I11393}
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0085}
{\up $}{\footnote\pard\plain{\up $} Startup}
{\up #}{\footnote\pard\plain{\up #} I11393}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} Initialize;Winsock}
\b _WSockStartUp( )
\par \pard \plain\fs20 Initializes the Winsock library. It appears that this function maps to the Windows Socket function WSAStartup. The following documentation is based on that assumption.
\par 
\par \b Syntax
\par \plain\fs20 
\par \f2\b lnresult = _WSockStarttUp(lnrequested, @lnbytes, @lnversion, @lcinfo1,;
\par \pard\fi715 @lcinfo2, @lnignore1, @lnignore2)
\par \pard \plain\fs20 
\par \f2\b lnrequested
\par \f11 
\par \plain\fs20 The requested version number of Winsock compliance in the form of a 16 bit integer. This information is stored in a high byte/low byte order. In his article, Calvin Hsia uses 513 (2.1) for this parameter. Whether or not the function can be used with versions of the Winsock specification below 2.0 is unknown. See remarks.
\par 
\par \f2\b @lnlevel
\par \plain\fs20 
\par The level of compliance that is supported. Most often, this will be equal to the value of \f2\b lnrequested\plain\fs20 . The value returned is in the same format as called. See remarks
\par \pard 
\par \f2\b @lnversion\plain\fs20 
\par 
\par This is the highest version of the Winsock specification that the caller can use. See remarks.
\par 
\par \f2\b Icinfo1 \plain\f2\fs20 and\b  icinfo2
\par \plain\fs20 
\par Theses character strings represent the information returned in the szDescription and szSystemStatus members respectively of the WSADATA structure. The first contains a description of the implementation. The second is any additional data that may be helpful in support.
\par 
\par \f2\b lnignore1 \plain\f2\fs20 and\b  lnignore2
\par 
\par \plain\fs20 These parameters represent the maximum number of sockets available and maximum message size. In implementations of the Windows Sockets greater than 1.1 they should be ignored as they are provided for backward compatibility only.
\par \pard 
\par \b Remarks
\par \plain\fs20 
\par Setting the desired version can be accomplished with the following:
\par 
\par \f2\b lnversion = BITLSHIFT(lnmajor, 8)
\par lnversion = lnversion + lnminor
\par \plain\fs20 
\par Where lnmajor is equal to the major version number, and lnminor is equal to the minor version number.
\par 
\par Retrieving the available version is as simple:
\par 
\par \f2\b lnminor = BITAND(lnversion, 255)
\par lnmaajor = BITAND(BITRSHIFT(lnversion, 8), 255)
\par 
\par \f11 See Also - \uldb \plain\uldb\fs20 _WSockCleanup\plain\fs20 {\v ZP_OWE}, \uldb _WSockGetHostByAddr\plain\fs20 {\v 3IFT2Z}\b 
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0086}
{\up $}{\footnote\pard\plain{\up $} Invalid}
{\up #}{\footnote\pard\plain{\up #} 0ZFR8E}
\pard\keepn\sb235\sa55 {\up K}{\footnote\pard\plain{\up K} Invalid;whandle}
Invalid whandles
\par \pard\li715\fi-355\tx715 \plain\fs20 
\par Passing an invalid whandle in VFP 6.0 SP3 generates error number 2028 (API call caused an exception). This does not cause VFP to terminate, however. In VFP 5.0a, this causes a general protection fault and VFP terminates. Care, therefore, should use to ascertain that the whandle is current and valid.
\par 
\par In general, apply the following rules:
\par 
\par 1.\tab Only store whandles in local variables. The exception to this would be a form with a custom property to hold the value.
\par \pard\li715\fi-355\tx355 2.\tab Check the return value of _EdGetEnv() when working with editing windows prior to calling one of the Editor functions. If the return value from this function is zero, then the window involved is not an edit window.
\par }